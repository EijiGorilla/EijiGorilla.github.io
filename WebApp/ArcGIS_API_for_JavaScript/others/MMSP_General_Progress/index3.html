<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <!--
  ArcGIS API for JavaScript, https://js.arcgis.com
  For more information about the views-switch-2d-3d sample, read the original sample description at developers.arcgis.com.
  https://developers.arcgis.com/javascript/latest/sample-code/views-switch-2d-3d/index.html
  -->
<title>Progress Summary (MMSP)</title>

<link rel="stylesheet" href="https://js.arcgis.com/4.25/esri/themes/dark/main.css"/>

<script type="module" src="https://js.arcgis.com/calcite-components/1.0.7/calcite.esm.js"></script>
<link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.0.7/calcite.css" />

<!-- Resources -->
<script src="https://cdn.amcharts.com/lib/4/core.js"></script>
<script src="https://cdn.amcharts.com/lib/4/charts.js"></script>
<script src="https://www.amcharts.com/lib/4/themes/dark.js"></script>
<script src="https://cdn.amcharts.com/lib/4/themes/animated.js"></script>
<script src="https://js.arcgis.com/4.26/"></script>

  </head>
  <body class="calcite-theme-dark">
    <calcite-loader></calcite-loader>
    <calcite-shell content-behind>
        <div id="applicationDiv">
          <div id="headerTitleDiv">Pre-Construction Work Progress</div>
            <div class="contentBox">
              <div class="container">
                  <div class="landStrucIsfBox">
                    <div id="landChartDiv"></div>
                    <div id="landChartDiv2"></div>
                    <div id="structureChartDiv"></div>
                  </div>
                <div class="treeBox">
                  <div id="isfChartDiv"></div>
                  <div id="treeCuttingChartDiv"></div>
                  <div id="treeCompenChartDiv"></div>
                </div>
                <div class="utilityBox">
                  <div id="utilityPointChartDiv"></div>
                  <div id="utilityLineChartDiv"></div>
                  <div id="utilityEmptyChartDiv"></div>
                </div>      
            </div>
            </div>
            <calcite-button icon-end="information-f"></calcite-button>
            <div id="item-description" hidden></div>
            <div id="legendChartDiv"></div>
          <div class="dateDiv">June 5, 2023</div>
          <div id="informationDiv"></div>
        </div>
    </calcite-shell>
  </body>

  <style>
    html,
body {
  padding: 0;
  margin: 0;
  background-color: #113149;
}

calcite-button {
  position: fixed;
  z-index: 1;
  top: 10;
  right:10;
}

#applicationDiv {
  display: flex;
  flex-wrap: wrap;
  height: 99%;
  margin: 0 auto;
  box-sizing: border-box;
  background-color: #113149;
}

#item-description {
  position: fixed;
  z-index: 1;
  bottom: 50;
  right: 10;

}

#item-description b {
  color: orange;
}

p {
  font-size: 0.8rem;
  width: auto;
  vertical-align: text-bottom;
  padding: 0;
  margin-top: 0;
}

calcite-shell {
  background-color: #113149;
}

calcite-action-bar {
  position: absolute;
  z-index: 99;
  top: 0;
  right: 0;
  margin: 1rem;
}

calcite-panel {
  position: absolute;
  z-index: 1;
  bottom: 10px;
  right: 300px;
  width: 30vw;
  height: 50%;
}
calcite-loader {
  align-self: center;
  justify-self: center;
}

calcite-label {
      --calcite-label-margin-bottom: 0px;
    }


#info-content {
      padding: 0.75rem;
    }

#informationDiv {
  position: absolute;
  z-index: 99;
  width: 30vw;
  height: 3vh;
  color: white;
  bottom: 190;
  right: 5;
  font-size: 1rem;
}

#informationDiv b {
  font-size: 1rem;
  color: orange;
  margin: 0;
  padding: 0;
}

.contentBox,
.contentBox2 {
  display: grid;
  grid-template-columns: 80vw 17.8vw;
  width: 100%;
  height: 88vh;
}

.container,
.container2 {
  display: grid;
  flex-wrap: wrap;
  height: 88vh;
  box-sizing: border-box;
  border-right: 0;
}


.containerB {
  font-size: 1.5vw;
  color: white;
  padding-top: 40%;
}

#headerTitleDiv {
  color: white;
  font-weight: bold;
  font-size: 1.8vw;
  margin: 0.5rem;

}

.dateDiv {
  z-index: 99;
  position: absolute;
  padding-bottom: 10;
  font-size: 1vw;
  color: rgb(0, 197, 255);
  right:10;
  bottom: 10;
}

.landStrucIsfBox,
.treeBox,
.landStrucIsfBox2,
.treeBox2 {
  display: inline-flex;
  height: 30.5vh;
  width: 100%;
  box-sizing: border-box;
  border-top: 0;
  border-bottom: 0;
  margin: 0;
  padding: 0;
  border-bottom: 0.7px solid rgb(185, 171, 171);
}

.utilityBox,
.utilityBox2 {
  display: inline-flex;
  height: 29.5vh;
  width: 100%;
  box-sizing: border-box;
  border-top: 0;
  border-bottom: 0;
  margin: 0;
  padding: 0;
}

#legendChartDiv {
  position: absolute;
  z-index: 99;
  right: 80;
  margin: 0;
  padding: 0;
  top: 0;
  background-color: rgba(0, 0, 0, 0);
  height: 50vh;
  width: 10vw;
}

#landChartDiv,
#landChartDiv2,
#structureChartDiv,
#isfChartDiv,
#treeCuttingChartDiv,
#treeCompenChartDiv,
#utilityPointChartDiv,
#utilityLineChartDiv,
#treeEmptyChartDiv,
#utilityEmptyChartDiv {
    width: 35%;
    height: 30vh;
    align-items: center;
    font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
    margin: 0;
    padding: 0;
    }

a {
  font-size: 1.2rem;
  color: white;
  font-weight: bold;
}

a:hover,
a:focus {
  color: rgb(185, 171, 171);
  font-size: 1.2rem;
}

ul {
list-style: none;
padding-left: 10;
line-height: 3rem;
}
â€‹

h2 {
  font-weight: 400;
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  font-style: normal;
  font-size: 23px;
  color: white;
  padding:3px;
  margin: 0px;
  width: 470px;
  vertical-align: text-top;
}



h3 {
  color: white;
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  text-align: center;
  font-weight: bold;
  font-size: 14px;
  padding: 10;
  width: 100%;

}

h4 {
  color: rgb(0, 197, 255);
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  text-align: left;
  font-weight: normal;
  font-size: 16px;
  padding-top: 20px;
  margin: 0;
  width: 160px;
  vertical-align: text-bottom;
}

h5 {
  color: rgb(0, 197, 255);
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  text-align: center;
  font-weight: bold;
  font-size: 14px;
  padding: 3;
  margin: 10;
}

h6 {
  color: rgb(0, 197, 255);
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  text-align: center;
  font-weight: normal;
  font-size: 30px;
  padding: 0px 0px 0px 0px;
  }
  
/* Browser Setting */
    ::-webkit-scrollbar {
        display: none;
    }


  </style>

  <script>
    require([
  "esri/Basemap",
  "esri/Map",
  "esri/views/MapView",
  "esri/views/SceneView",
  "esri/layers/FeatureLayer",
  "esri/layers/support/FeatureFilter",
  "esri/layers/SceneLayer",
  "esri/layers/Layer",
  "esri/layers/TileLayer",
  "esri/layers/VectorTileLayer",
  "esri/layers/support/LabelClass",
  "esri/symbols/LabelSymbol3D",
  "esri/WebMap",
  "esri/WebScene",
  "esri/portal/PortalItem",
  "esri/portal/Portal",
  "esri/widgets/TimeSlider",
  "esri/widgets/Legend",
  "esri/widgets/LayerList",
  "esri/widgets/Fullscreen",
  "esri/rest/geometryService",
  "esri/rest/support/Query",
  "esri/rest/support/StatisticDefinition",
  "esri/symbols/WebStyleSymbol",
  "esri/TimeExtent",
  "esri/widgets/Expand",
  "esri/widgets/Editor",
  "esri/renderers/UniqueValueRenderer",
  "esri/widgets/support/DatePicker",
  "esri/widgets/FeatureTable",
  "esri/widgets/Compass",
  "esri/layers/ElevationLayer",
  "esri/Ground",
  "esri/layers/GraphicsLayer",
  "esri/widgets/Search",
], function(Basemap, Map, MapView, SceneView, 
            FeatureLayer, FeatureFilter,
            SceneLayer, Layer, TileLayer, VectorTileLayer,
            LabelClass, LabelSymbol3D, WebMap,
            WebScene, PortalItem, Portal,
            TimeSlider, Legend, LayerList, Fullscreen,
            geometryService, Query,
            StatisticDefinition, WebStyleSymbol,
            TimeExtent, Expand, Editor, UniqueValueRenderer, DatePicker,
            FeatureTable, Compass, ElevationLayer, Ground,
            GraphicsLayer, Search) {

////////////////////////////////////////////////////
var basemap = new Basemap({
  baseLayers: [
    new VectorTileLayer({
      portalItem: {
        id: "8a9ef2a144e8423786f6139408ac3424" // 3a62040541b84f528da3ac7b80cf4a63
      }
    })
  ]
});

   var map = new Map({
        basemap: basemap, //"gray-vector", // "streets-night-vector", basemap
        ground: "world-elevation"
  }); 
  //map.ground.surfaceColor = "#FFFF";
  //map.ground.opacity = 0.5;


  //
  function shiftCamera(deg) {
    var camera = view.camera.clone();
    camera.position.longitude += deg;
    return camera;
  }

  function catchAbortError(error) {
    if (error.name != "AbortError") {
      console.error(error);
    }
  }

  // Setup UI




//*******************************//
// Import Layers                 //
//*******************************//
var lotLayer = new FeatureLayer({
    portalItem: {
            id: "032432d931624de9bf5ff03f1f9d7016",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
        layerId: 1,
  outFields: ["*"],
  title: "Status of Land Acquisition",
  labelsVisible: false,
});


// Structure
var structureLayer = new FeatureLayer({
    portalItem: {
            id: "ec9dac0c16af4797bb917a0babc735e9",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
  title: "Status of Structure",
  outFields: ["*"]
});


// Relocation Status point layer
var reloISFLayer = new FeatureLayer({
portalItem: {
id: "a2e32eb82db84b3a8006e1c1e2cd7874",
portal: {
url: "https://gis.railway-sector.com/portal"
}
},
  outFields: ["*"],
  title: "Status for Relocation (ISF)"
});
//reloISFLayer.listMode = "hide";



// Tree Cutting
var treeLayer = new FeatureLayer ({
portalItem: {
id: "30cdb9f9775146308a05dd17cfbfa87a",
portal: {
  url: "https://gis.railway-sector.com/portal"
}
},
layerId: 1,
elevationInfo: {
      mode: "on-the-ground"
    },
outFields: ["*"],
title: "Status of Tree Cutting",

});


// Utility Relocation (Point)
var utilPointLayer = new FeatureLayer({
portalItem: {
id: "ff7177760e1c43478c1ad6088c48cfa8",
portal: {
  url: "https://gis.railway-sector.com/portal"
}
},
layerId: 4,
title: "Utility Point",
outFields: ["*"],
elevationInfo: {
      mode: "on-the-ground"
    }
});

// Utility Relocation (Line)
var utilLineLayer = new FeatureLayer({
portalItem: {
id: "ff7177760e1c43478c1ad6088c48cfa8",
portal: {
  url: "https://gis.railway-sector.com/portal"
}
},
layerId: 5,
title: "Utility Line",
elevationInfo: {
mode: "relative-to-scene",
featureExpressionInfo: {
 expression: "$feature.height"
},
unit: "meters"
//offset: 0
},
outFields: ["*"],

});


/////////////////////////////////////////////////////////////////////
var applicationDiv = document.getElementById("applicationDiv");

var headerDiv = document.getElementById("headerDiv");
var headerTitleDiv = document.getElementById("headerTitleDiv");

// Land, structure, and ISF
var landChartDiv = document.getElementById("landChartDiv");
var structureChartDiv = document.getElementById("structureChartDiv");
var isfChartDiv = document.getElementById("isfChartDiv");

// Tree cutting and tree compensation
var treeCuttingChartDiv = document.getElementById("treeCuttingChartDiv");
var treeCompenChartDiv = document.getElementById("treeCompenChartDiv");

// Utitlity Relocation
var utilityPointChartDiv = document.getElementById("utilityPointChartDiv");
var utilityLineChartDiv = document.getElementById("utilityLineChartDiv");

var informationDiv = document.getElementById("informationDiv");

//informationDiv.innerHTML =  "<br>" + "<b>" + "Note:" + "</b>" + "<br>" + "<br>" + "* Each gauge shows percent progress of each CP in the sliced chart.";
//informationDiv.innerHTML =  `<b>Note:</b><br>
//                             <p>1. The sliced areas in gauges show percent progress of CPs.</p>
//                             2. <b>Click</b> the title of gauges to access individual web mapping applications for more detailed information.`

// Thousand separators function
function thousands_separators(num)
{
var num_parts = num.toString().split(".");
num_parts[0] = num_parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
return num_parts.join(".");
}

////////// Chart Begins //////////////////
am4core.ready(function() {

// Themes begin
am4core.useTheme(am4themes_animated);

////////////////////////////
// Color definition
const axis1TickColor = "#C5C5C5";
const color_101  = "#ffa500";
const color_102  = "#00ff00";
const color_103 = "#70AD47";
const color_104 = "#ffff00";
const color_105 = "#bf40bf";
const color_108 = "#ff7f7f";
const color_109 = "#cdaa66";
const color_handedOver = "#00c5ff"

const BOTTOM_LABEL_COL = am4core.color("#C5C5C5");
const TOP_TITLE_COL = am4core.color("#FFFFFF");
const chartTitleLabelFillCol = "#00C3FF";

// Gauge Needle (hand) length
const NEEDLE_LENGTH = am4core.percent(70);

// chart title
const titleFontSize = "1.7em";
const labelMarginTop = -5;
const title_land = "[bold]LAND";
const title_struc = "[bold]EXISTING STRUCTURE";
const title_ifs = "[bold]INFORMAL SETTLERS";
const title_treeCut = "[bold]TREE CUTTING";
const title_treeCommpen = "[bold]TREE COMPENSATION";
const title_utility = "[bold]UTILITY";

/////////////////////////////////////////

// Legend
function legendPackage() {
  
  var chart = am4core.create("legendChartDiv", am4charts.PieChart);
  
  
  // Add data
  chart.data = [
  {
    "CP": "All CPs (%)",
    "status": 0,
    "color": am4core.color(color_handedOver)
  },
  {
    "CP": "CP 101 (%)",
    "status": 0,
    "color": am4core.color(color_101)
  },
  {
    "CP": "CP 102 (%)",
    "status": 0,
    "color": am4core.color(color_102)
  },
  {
    "CP": "CP 103 (%)",
    "status": 0,
    "color": am4core.color(color_103)   
  },
  {
    "CP": "CP 104 (%)",
    "status": 0,
    "color": am4core.color(color_104) 
  },
  {
    "CP": "CP 105 (%)",
    "status": 0,
    "color": am4core.color(color_105)
  },
  {
    "CP": "CP 108 (%)",
    "status": 0,
    "color": am4core.color(color_108)
  },
  {
    "CP": "CP 109 (%)",
    "status": 0,
    "color": am4core.color(color_109)
  },
  ];
  
  // Set inner radius
  chart.innerRadius = am4core.percent(0);
  chart.radius = am4core.percent(0);
  // Add and configure Series
  
  function createSlices(field, status){
  var pieSeries = chart.series.push(new am4charts.PieSeries());
  pieSeries.dataFields.value = field;
  pieSeries.dataFields.category = status;
  pieSeries.disabled = true;
  pieSeries.slices.template.propertyFields.fill = "color";
  pieSeries.slices.template.stroke = am4core.color("#fff");
  pieSeries.slices.template.strokeWidth = 0;
  pieSeries.slices.template.strokeOpacity = 1;
  
  pieSeries.slices.template
  // change the cursor on hover to make it apparent the object can be interacted with
  .cursorOverStyle = [
  {
  "property": "cursor",
  "value": "pointer"
  }
  ];
  
  
  // Add a legend
  const LegendFontSizze = "1em";
  chart.legend = new am4charts.Legend();
  
  chart.legend.valueLabels.template.align = "right"
  chart.legend.valueLabels.template.textAlign = "end";  

  
  //chart.legend.position = "bottom";
  chart.legend.labels.template.fontSize = LegendFontSizze;
  chart.legend.labels.template.fill = "#ffffff";
  chart.legend.valueLabels.template.fill = am4core.color("#ffffff"); 
  pieSeries.legendSettings.valueText = "{ }"; 
  //pieSeries.legendSettings.valueText = "{value.percent.formatNumber('#.')}% ({value})";
  //pieSeries.legendSettings.labelText = "Series: [bold {color}]{category}[/]";
  
  // Responsive code for chart
  chart.responsive.enabled = true;
  chart.responsive.useDefault = false
  
  chart.responsive.rules.push({
  relevant: function(target) {
  if (target.pixelWidth <= 400) {
    return true;
  }
  return false;
  },
  state: function(target, stateId) {
  if (target instanceof am4charts.PieSeries) {
    var state = target.states.create(stateId);
        
    var labelState = target.labels.template.states.create(stateId);
    labelState.properties.disabled = true;
        
    var tickState = target.ticks.template.states.create(stateId);
    tickState.properties.disabled = true;
    return state;
  }
  if (target instanceof am4charts.Legend) {
    var state = target.states.create(stateId);
    state.properties.paddingTop = 0;
    state.properties.paddingRight = 0;
    state.properties.paddingBottom = 0;
    state.properties.paddingLeft = 0;
    state.properties.marginLeft = 0;
    return state;
  }
  return null;
  }
  });
  // Responsive code for chart
  
  // Chart Title
  //var title = chart.titles.create();
  //title.text = "Land"; // [#00ff00]world[/], Hello [font-size: 30px]world[/]
  //title.fontSize = 20;
  //title.fontWeight = "bold";
  //title.fill = "#ffffff";
  //title.marginTop = 5;
  
  var marker = chart.legend.markers.template.children.getIndex(0);
  var markerTemplate = chart.legend.markers.template;
  //marker.cornerRadius(12, 12, 12, 12); round legend marker
  marker.strokeWidth = 1;
  marker.strokeOpacity = 1;
  marker.stroke = am4core.color("#ccc");
  
  // Change size of legend marker
  markerTemplate.width = 18;
  markerTemplate.height = 18;
  // This creates initial animation
  //pieSeries.hiddenState.properties.opacity = 1;
  //pieSeries.hiddenState.properties.endAngle = -90;
  //pieSeries.hiddenState.properties.startAngle = -90;

  
  } // End of createSlices function
  
  createSlices("status", "CP");
  

  } // End of updateChartLot()
  legendPackage();
  
// Calculate Statistcis
// Land, Structure, and ISF

//////////////////////////////////////////
const onStatisticField_total = "CASE WHEN StatusNVS3 >= 1 THEN 1 ELSE 0 END";
//////////////////////////////////////////

/// 1. Land (Station)
function totalLotNumberStation() {
    var total_number_lot = {
        onStatisticField: onStatisticField_total,
        outStatisticFieldName: "total_number_lot",
        statisticType: "sum"
    };

    var query = lotLayer.createQuery();
    query.outStatistics = [total_number_lot];
    query.where = "Type = 'Station'";

    return lotLayer.queryFeatures(query).then(function(response) {
        var stats = response.features[0].attributes;

        const totalNumberLot = stats.total_number_lot;
        //const LOT_HANDOVER_PERC = (handedOver/affected)*100;
        return totalNumberLot;
    });
}

function lotSummaryStation(totalNumberLot) {
    var total_lot_number = {
        onStatisticField: onStatisticField_total,
        outStatisticFieldName: "total_lot_number",
        statisticType: "sum"
    }

    var total_lot_handedOver = {
        onStatisticField: "CASE WHEN HandedOver = 1 THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_lot_handedOver",
        statisticType: "sum"
    }

var query = lotLayer.createQuery();
query.outStatistics = [total_lot_number, total_lot_handedOver];
query.returnGeometry = true;
query.where = "Type = 'Station'";
query.groupByFieldsForStatistics = ["Package"];

    var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return lotLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
const attributes = result.attributes;
const cpPackage = result.attributes.Package;
const totalLot = attributes.total_lot_number;
const totalHandedOver = attributes.total_lot_handedOver;
const LOT_HANDOVER_PERC = (totalHandedOver/totalNumberLot)*100;
const lot_handedover_perc = (totalHandedOver/totalLot)*100;

if (cpPackage === 'CP101') {
  cp101.push(LOT_HANDOVER_PERC);
  cp101_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP102') {
  cp102.push(LOT_HANDOVER_PERC);
  cp102_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP103') {
  cp103.push(LOT_HANDOVER_PERC);
  cp103_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP104') {
  cp104.push(LOT_HANDOVER_PERC);
  cp104_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP105') {
  cp105.push(LOT_HANDOVER_PERC);
  cp105_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP108') {
  cp108.push(LOT_HANDOVER_PERC);
  cp108_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP109') {
  cp109.push(LOT_HANDOVER_PERC);
  cp109_a.push(lot_handedover_perc);
}


});

return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of lotSummary function

function laFigureLotStation([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};

/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("landChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color


var title = chart.titles.create();
//'<a href="https://google.com"}">More info</a>'

title.text = "LAND (Station)";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Land_Structure/index4.html" target="_blank">LAND (Station)</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

//var sourceLabel = chart.createChild(am4core.Label);
//sourceLabel.html = '<a href="https://google.com">Test</a>';

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]HANDED-OVER";
//label.html = '<a href="https://google.com">HANDED-OVER AREA</a>';
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1; // default 0.8 fill-color of 
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)

}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function lotChart() {
  totalLotNumberStation()
.then(lotSummaryStation)
.then(laFigureLotStation);
}

// Land (Subterranean)
function totalLotNumberStation2() {
    var total_number_lot = {
        onStatisticField: onStatisticField_total,
        outStatisticFieldName: "total_number_lot",
        statisticType: "sum"
    };

    var query = lotLayer.createQuery();
    query.outStatistics = [total_number_lot];
    query.where = "Type = 'Subterranean'";

    return lotLayer.queryFeatures(query).then(function(response) {
        var stats = response.features[0].attributes;

        const totalNumberLot = stats.total_number_lot;
        //const LOT_HANDOVER_PERC = (handedOver/affected)*100;
        return totalNumberLot;
    });
}

function lotSummaryStation2(totalNumberLot) {
    var total_lot_number = {
        onStatisticField: onStatisticField_total,
        outStatisticFieldName: "total_lot_number",
        statisticType: "sum"
    }

    var total_lot_handedOver = {
        onStatisticField: "CASE WHEN HandedOver = 1 THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_lot_handedOver",
        statisticType: "sum"
    }

var query = lotLayer.createQuery();
query.outStatistics = [total_lot_number, total_lot_handedOver];
query.returnGeometry = true;
query.where = "Type = 'Subterranean'";
query.groupByFieldsForStatistics = ["Package"];

    var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return lotLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
const attributes = result.attributes;
const cpPackage = result.attributes.Package;
const totalLot = attributes.total_lot_number;
const totalHandedOver = attributes.total_lot_handedOver;
const LOT_HANDOVER_PERC = (totalHandedOver/totalNumberLot)*100;
const lot_handedover_perc = (totalHandedOver/totalLot)*100;

if (cpPackage === 'CP101') {
  cp101.push(LOT_HANDOVER_PERC);
  cp101_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP102') {
  cp102.push(LOT_HANDOVER_PERC);
  cp102_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP103') {
  cp103.push(LOT_HANDOVER_PERC);
  cp103_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP104') {
  cp104.push(LOT_HANDOVER_PERC);
  cp104_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP105') {
  cp105.push(LOT_HANDOVER_PERC);
  cp105_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP108') {
  cp108.push(LOT_HANDOVER_PERC);
  cp108_a.push(lot_handedover_perc);

} else if (cpPackage === 'CP109') {
  cp109.push(LOT_HANDOVER_PERC);
  cp109_a.push(lot_handedover_perc);
}


});

return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of lotSummary function

function laFigureLotStation2([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};

/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("landChartDiv2", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color


var title = chart.titles.create();
//'<a href="https://google.com"}">More info</a>'

title.text = "LAND (Subterranean)";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Land_Structure/index4.html" target="_blank">LAND (Subterranean)</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

//var sourceLabel = chart.createChild(am4core.Label);
//sourceLabel.html = '<a href="https://google.com">Test</a>';

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]HANDED-OVER";
//label.html = '<a href="https://google.com">HANDED-OVER AREA</a>';
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1; // default 0.8 fill-color of 
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)

}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function lotChart2() {
  totalLotNumberStation2()
.then(lotSummaryStation2)
.then(laFigureLotStation2);
}


/// 2. Structure
const onStatisticField_demolished = "CASE WHEN REMARKS = 'Demolished' THEN 1 ELSE 0 END"
const onStatisticField_paid = "CASE WHEN Status = 1 THEN 1 ELSE 0 END";

function totalStructureNumber() {
    var total_number_struc = {
        onStatisticField: "CASE WHEN Status >=1 THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_number_struc",
        statisticType: "sum"
    };

    var query = structureLayer.createQuery();
    query.outStatistics = [total_number_struc];

    return structureLayer.queryFeatures(query).then(function(response) {
        var stats = response.features[0].attributes;

        const totalNumberStruc = stats.total_number_struc;
        //const LOT_HANDOVER_PERC = (handedOver/affected)*100;
        return totalNumberStruc;
    });
}

function strucSummary(totalNumberStruc) {
    var total_number_struc = {
        onStatisticField: "CASE WHEN Status >=1 THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_number_struc",
        statisticType: "sum"
    };

    var total_paid_struc = {
    onStatisticField: onStatisticField_demolished,
    outStatisticFieldName: "total_paid_struc",
    statisticType: "sum"
    }

var query = structureLayer.createQuery();
query.outStatistics = [total_number_struc, total_paid_struc];
query.returnGeometry = true;
query.groupByFieldsForStatistics = ["Package"];

    var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return structureLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
    const attributes = result.attributes;
    const cpPackage = result.attributes.Package;
    const totalStruc = attributes.total_number_struc;
    const totalPaid = attributes.total_paid_struc;
    const STRUC_PAID_PERC = (totalPaid/totalNumberStruc)*100;
    const struc_paid_perc = (totalPaid/totalStruc)*100;

if (cpPackage === 'CP101') {
  cp101.push(STRUC_PAID_PERC);
  cp101_a.push(struc_paid_perc);

} else if (cpPackage === 'CP102') {
  cp102.push(STRUC_PAID_PERC);
  cp102_a.push(struc_paid_perc);

} else if (cpPackage === 'CP103') {
  cp103.push(STRUC_PAID_PERC);
  cp103_a.push(struc_paid_perc);

} else if (cpPackage === 'CP104') {
  cp104.push(STRUC_PAID_PERC);
  cp104_a.push(struc_paid_perc);

} else if (cpPackage === 'CP105') {
  cp105.push(STRUC_PAID_PERC);
  cp105_a.push(struc_paid_perc);

} else if (cpPackage === 'CP108') {
  cp108.push(STRUC_PAID_PERC);
  cp108_a.push(struc_paid_perc);

} else if (cpPackage === 'CP109') {
  cp109.push(STRUC_PAID_PERC);
  cp109_a.push(struc_paid_perc);
}

});

return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of strucSummary function

function laFigureStruc([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
    const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};


/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("structureChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color

var title = chart.titles.create();
title.text = "EXISTING STRUCTURE";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Land_Structure/index4.html" target="_blank">EXISTING STRUCTURE</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]DEMOLISHED";
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7; // 0.3 // category labels: CP101, CP102,....



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1;
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)
}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function structureChart() {
  totalStructureNumber()
  .then(strucSummary)
  .then(laFigureStruc);
}


/// 3. ISF
function isfTotalArea() {
    var total_number_isf = {
        onStatisticField: "RELOCATION",
        outStatisticFieldName: "total_number_isf",
        statisticType: "count"
    };

var query = reloISFLayer.createQuery();
query.outStatistics = [total_number_isf];

return reloISFLayer.queryFeatures(query).then(function(response) {
var stats = response.features[0].attributes;

const totalNumberISF = stats.total_number_isf;
//const LOT_HANDOVER_PERC = (handedOver/affected)*100;
return totalNumberISF;
});
}

function isfSummary(totalNumberISF) {
  var total_number_isf = {
    onStatisticField: "RELOCATION",
    outStatisticFieldName: "total_number_isf",
    statisticType: "count"
  }

var total_relocation_isf = {
  onStatisticField: "CASE WHEN RELOCATION = 'RELOCATED' THEN 1 ELSE 0 END",
  outStatisticFieldName: "total_relocation_isf",
  statisticType: "sum"
}

var query = reloISFLayer.createQuery();
query.outStatistics = [total_number_isf, total_relocation_isf];
query.returnGeometry = true;
query.groupByFieldsForStatistics = ["Package"];

    var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return reloISFLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
    const attributes = result.attributes;
    const cpPackage = result.attributes.Package;
    const totalIsf = attributes.total_number_isf;
    const totalRelocated = attributes.total_relocation_isf;
    const ISF_RELOCATED_PERC = (totalRelocated/totalNumberISF)*100;
    const isf_relocated_perc = (totalRelocated/totalIsf)*100;


if (cpPackage === 'CP101') {
  cp101.push(ISF_RELOCATED_PERC);
  cp101_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP102') {
    cp102.push(ISF_RELOCATED_PERC);
    cp102_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP103') {
    cp103.push(ISF_RELOCATED_PERC);
    cp103_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP104') {
    cp104.push(ISF_RELOCATED_PERC);
    cp104_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP105') {
    cp105.push(ISF_RELOCATED_PERC);
    cp105_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP108') {
    cp108.push(ISF_RELOCATED_PERC);
    cp108_a.push(isf_relocated_perc);

} else if (cpPackage === 'CP109') {
    cp109.push(ISF_RELOCATED_PERC);
    cp109_a.push(isf_relocated_perc);
}

});
return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of isfSummary function

function laFigureIsf([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
    const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
  score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};
/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("isfChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color

var title = chart.titles.create();
title.text = "INFORMAL SETTLERS";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Land_Structure/index4.html" target="_blank">INFORMAL SETTLERS</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]RELOCATED";
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1;
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)
}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function isfChart() {
  isfTotalArea()
  .then(isfSummary)
  .then(laFigureIsf);
}


// Tree

/// 1. Tree Cutting
function treeCuttingTotal() {
    var total_number_tree = {
        onStatisticField: "CASE WHEN (TCP_Proces >= 1 AND TCP_Proces <= 7) THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_number_tree",
        statisticType: "sum"
    };

var query = treeLayer.createQuery();
query.outStatistics = [total_number_tree];

return treeLayer.queryFeatures(query).then(function(response) {
var stats = response.features[0].attributes;
const totalNumberTree = stats.total_number_tree;

//const LOT_HANDOVER_PERC = (handedOver/affected)*100;
return totalNumberTree;
});
}

function treeCutSummary(totalNumberTree) {
    var total_number_tree = {
        onStatisticField: "CASE WHEN (TCP_Proces >= 1 AND TCP_Proces <= 7) THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_number_tree",
        statisticType: "sum"
    };

    var total_cutearthballed_tree = {
        onStatisticField: "CASE WHEN (TCP_Proces = 5 or TCP_Proces = 6) THEN 1 ELSE 0 END",
        outStatisticFieldName: "total_cutearthballed_tree",
        statisticType: "sum"
    }

var query = treeLayer.createQuery();
query.outStatistics = [total_number_tree, total_cutearthballed_tree];
query.returnGeometry = true;
query.groupByFieldsForStatistics = ["Package"];

var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return treeLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
    const attributes = result.attributes;
    const cpPackage = result.attributes.Package;
    const totalTree = attributes.total_number_tree;
    const totalCut = attributes.total_cutearthballed_tree;
    const TREE_CUT_PERC = (totalCut/totalNumberTree)*100;
    const tree_cut_perc = (totalCut/totalTree)*100;


    if (cpPackage === 'CP101') {
    cp101.push(TREE_CUT_PERC);
    cp101_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP102') {
    cp102.push(TREE_CUT_PERC);
    cp102_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP103') {
    cp103.push(TREE_CUT_PERC);
    cp103_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP104') {
    cp104.push(TREE_CUT_PERC);
    cp104_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP105') {
    cp105.push(TREE_CUT_PERC);
    cp105_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP108') {
    cp108.push(TREE_CUT_PERC);
    cp108_a.push(tree_cut_perc);

    } else if (cpPackage === 'CP109') {
    cp109.push(TREE_CUT_PERC);
    cp109_a.push(tree_cut_perc);
    }

});

return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of treeCutSummary function

function treeCuttingFigure([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
    const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
  score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};

/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("treeCuttingChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color

var title = chart.titles.create();
title.text = "TREE CUTTING";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Tree_Cutting/index.html" target="_blank">TREE CUTTING</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]CUT/EARTHBALLED";
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1;
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)
}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function treeCuttingChart() {
  treeCuttingTotal()
  .then(treeCutSummary)
  .then(treeCuttingFigure);
}


// Tree Compensation
function treeCompenTotal() {
var total_number_tree = {
onStatisticField: "CASE WHEN Tree_Compe >= 1 THEN 1 ELSE 0 END",
outStatisticFieldName: "total_number_tree",
statisticType: "sum"
};

var query = treeLayer.createQuery();
query.outStatistics = [total_number_tree];

return treeLayer.queryFeatures(query).then(function(response) {
var stats = response.features[0].attributes;
const totalNumberTree = stats.total_number_tree;

return totalNumberTree;
});
}

function treeCompenSummary(totalNumberTree) {
  var total_number_tree = {
    onStatisticField: "CASE WHEN Tree_Compe >= 1 THEN 1 ELSE 0 END",
    outStatisticFieldName: "total_number_tree",
    statisticType: "sum"
    };

    var total_compensated_tree = {
    onStatisticField: "CASE WHEN Tree_Compe = 7 THEN 1 ELSE 0 END",
    outStatisticFieldName: "total_compensated_tree",
    statisticType: "sum"
    }

var query = treeLayer.createQuery();
query.outStatistics = [total_number_tree, total_compensated_tree];
query.returnGeometry = true;
query.groupByFieldsForStatistics = ["Package"];

var cp101 = [];
    var cp101_a = [];

    var cp102 = [];
    var cp102_a = [];

    var cp103 = [];
    var cp103_a = [];

    var cp104 = [];
    var cp104_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp105 = [];
    var cp105_a = [];

    var cp108 = [];
    var cp108_a = [];

    var cp109 = [];
    var cp109_a = [];

return treeLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
    const attributes = result.attributes;
    const cpPackage = result.attributes.Package;
    const totalTree = attributes.total_number_tree;
    const totalCompen = attributes.total_compensated_tree;
    const TREE_COMPEN_PERC = (totalCompen/totalNumberTree)*100;
    const tree_compen_perc = (totalCompen/totalTree)*100;

    if (cpPackage === 'CP101') {
    cp101.push(TREE_COMPEN_PERC);
    cp101_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP102') {
    cp102.push(TREE_COMPEN_PERC);
    cp102_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP103') {
    cp103.push(TREE_COMPEN_PERC);
    cp103_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP104') {
    cp104.push(TREE_COMPEN_PERC);
    cp104_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP105') {
    cp105.push(TREE_COMPEN_PERC);
    cp105_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP108') {
    cp108.push(TREE_COMPEN_PERC);
    cp108_a.push(tree_compen_perc);

    } else if (cpPackage === 'CP109') {
    cp109.push(TREE_COMPEN_PERC);
    cp109_a.push(tree_compen_perc);
    }
});
return [cp101, cp102, cp103, cp104, cp105, cp108, cp109,
        cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a];
});

} // End of treeCompenSummary function

function treeCompenFigure([cp101, cp102, cp103, cp104, cp105, cp108, cp109, cp101_a, cp102_a, cp103_a, cp104_a, cp105_a, cp108_a, cp109_a]) {
    const totalScore = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

const CP101 = Number(cp101);
const CP102 = Number(cp101) + Number(cp102);
const CP103 = Number(cp101) + Number(cp102) + Number(cp103);
const CP104 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104);
const CP105 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105);
const CP108 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108);
const CP109 = Number(cp101) + Number(cp102) + Number(cp103) + Number(cp104) + Number(cp105) + Number(cp108) + Number(cp109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
  score: totalScore,
gradingData: [
{
  title: isNaN(cp101_a) ? "" : Number(cp101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP101
},
{
  title: isNaN(cp102_a) ? "" : Number(cp102_a).toFixed(0),
  color: color_102,
  lowScore: CP101,
  highScore: CP102
},
{
  title: isNaN(cp103_a) ? "" : Number(cp103_a).toFixed(0),
  color: color_103,
  lowScore: CP102,
  highScore: CP103
},
{
  title: isNaN(cp104_a) ? "" : Number(cp104_a).toFixed(0),
  color: color_104,
  lowScore: CP103,
  highScore: CP104
},
{
  title: isNaN(cp105_a) ? "" : Number(cp105_a).toFixed(0),
  color: color_105,
  lowScore: CP104,
  highScore: CP105
},
{
  title: isNaN(cp108_a) ? "" : Number(cp108_a).toFixed(0),
  color: color_108,
  lowScore: CP105,
  highScore: CP108
},
{
  title: isNaN(cp109_a) ? "" : Number(cp109_a).toFixed(0),
  color: color_109,
  lowScore: CP108,
  highScore: CP109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP109,
  highScore: 100
}
]
};


/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("treeCompenChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color

var title = chart.titles.create();
title.text = "TREE COMPENSATION";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/envi/Operational/MMSP_Tree_Cutting/index.html" target="_blank">TREE COMPENSATION</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]COMPENSATED";
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1;
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)
}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%"; //data.score.toFixed(0).toString() + "%"
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function treeCompensationChart() {
  treeCompenTotal()
  .then(treeCompenSummary)
  .then(treeCompenFigure);
}


// Utility Point + Line Total Number
function utilityPointTotal() {
var total_number_utilPoint = {
onStatisticField: "Status",
outStatisticFieldName: "total_number_utilPoint",
statisticType: "count"
};

var query = utilPointLayer.createQuery();
query.outStatistics = [total_number_utilPoint];

return utilPointLayer.queryFeatures(query).then(function(response) {
var stats = response.features[0].attributes;
const totalNumberPoint = stats.total_number_utilPoint;

return totalNumberPoint;
});
}

function utilityLineTotal(totalNumberPoint) {
var total_number_utilLine = {
onStatisticField: "Status",
outStatisticFieldName: "total_number_utilLine",
statisticType: "count"
};

var query = utilLineLayer.createQuery();
query.outStatistics = [total_number_utilLine];

return utilLineLayer.queryFeatures(query).then(function(response) {
var stats = response.features[0].attributes;
const totalNumberLine = stats.total_number_utilLine;
const grandTotal = Number(totalNumberPoint) + Number(totalNumberLine);

return grandTotal;
});
}

// Utility Point + Line Total Completed
function utilityPointCompleted(grandTotal) {
  var total_number_utilPoint = {
    onStatisticField: "Status",
    outStatisticFieldName: "total_number_utilPoint",
    statisticType: "count"
    };

var total_completed_utilPoint = {
onStatisticField: "CASE WHEN Status = 1 THEN 1 ELSE 0 END",
outStatisticFieldName: "total_completed_utilPoint",
statisticType: "sum"
};

var query = utilPointLayer.createQuery();
query.outStatistics = [total_number_utilPoint, total_completed_utilPoint];
query.groupByFieldsForStatistics = ["Package"];

var point_CP101 = [];
var point_CP101_a = [];

var point_CP102 = [];
var point_CP102_a = [];

var point_CP103 = [];
var point_CP103_a = [];

var point_CP104 = [];
var point_CP104_a = [];

var point_CP105 = [];
var point_CP105_a = [];

var point_CP108 = [];
var point_CP108_a = [];

var point_CP109 = [];
var point_CP109_a = [];

return utilPointLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
const attributes = result.attributes;
const cpPackage = result.attributes.Package;
const completed = attributes.total_completed_utilPoint;
const totalUtilPoint = attributes.total_number_utilPoint;

if (cpPackage === 'CP101') {
  point_CP101.push(completed);
  point_CP101_a.push(totalUtilPoint);

} else if (cpPackage === 'CP102') {
  point_CP102.push(completed);
  point_CP102_a.push(totalUtilPoint);

} else if (cpPackage === 'CP103') {
  point_CP103.push(completed);
  point_CP103_a.push(totalUtilPoint);

} else if (cpPackage === 'CP104') {
  point_CP104.push(completed);
  point_CP104_a.push(totalUtilPoint);

} else if (cpPackage === 'CP105') {
  point_CP105.push(completed);
  point_CP105_a.push(totalUtilPoint);

} else if (cpPackage === 'CP108') {
  point_CP108.push(completed);
  point_CP108_a.push(totalUtilPoint);

} else if (cpPackage === 'CP109') {
  point_CP109.push(completed);
  point_CP109_a.push(totalUtilPoint);
}
});

return [point_CP101, point_CP102, point_CP103, point_CP104, point_CP105, point_CP108, point_CP109,
        point_CP101_a, point_CP102_a, point_CP103_a, point_CP104_a, point_CP105_a, point_CP108_a,point_CP109_a, grandTotal];
});
}


function utilityLineCompleted([point_CP101, point_CP102, point_CP103, point_CP104, point_CP105, point_CP108, point_CP109, point_CP101_a, point_CP102_a, point_CP103_a, point_CP104_a, point_CP105_a, point_CP108_a, point_CP109_a, grandTotal]) {

  var total_number_utilLine = {
    onStatisticField: "Status",
    outStatisticFieldName: "total_number_utilLine",
    statisticType: "count"
    };

  var total_completed_utilLine = {
  onStatisticField: "CASE WHEN Status = 1 THEN 1 ELSE 0 END",
  outStatisticFieldName: "total_completed_utilLine",
  statisticType: "sum"
};

var query = utilLineLayer.createQuery();
query.outStatistics = [total_number_utilLine, total_completed_utilLine];
query.groupByFieldsForStatistics = ["Package"];

// Numeric
const gTotal = Number(grandTotal);

//

var totalCompleted_CP101 = [];
var totalCompleted_CP102 = [];
var totalCompleted_CP103 = [];
var totalCompleted_CP104 = [];
var totalCompleted_CP105 = [];
var totalCompleted_CP108 = [];
var totalCompleted_CP109 = [];

var totalUtil_CP101 = [];
var totalUtil_CP102 = [];
var totalUtil_CP103 = [];
var totalUtil_CP104 = [];
var totalUtil_CP105 = [];
var totalUtil_CP108 = [];
var totalUtil_CP109 = [];

return utilLineLayer.queryFeatures(query).then(function(response) {
stats = response.features;

stats.forEach((result, index) => {
const attributes = result.attributes;
const cpPackage = result.attributes.Package;
const completed = attributes.total_completed_utilLine;
const totalUtilLine = attributes.total_number_utilLine;

const completedLine = Number(completed);

//const LINE_COMPLETED_PERC = (completed/totalCompen)*100;

if (cpPackage === 'CP101') {
  const tempComp_CP101 = completedLine + Number(point_CP101);
  totalCompleted_CP101.push(tempComp_CP101);

  const totalCount_CP101 = totalUtilLine + Number(point_CP101_a);
  //headerTitleDiv.innerHTML = totalUtilLine + "; " + point_CP101_a + " = " + totalCount_CP11;
  totalUtil_CP101.push(totalCount_CP101);

} else if (cpPackage === 'CP102') {
  const tempComp_CP102 = completedLine + Number(point_CP102);
  totalCompleted_CP102.push(tempComp_CP102);

  const totalCount_CP102 = totalUtilLine +  Number(point_CP102_a);
  totalUtil_CP102.push(totalCount_CP102);

} else if (cpPackage === 'CP103') {
  const tempComp_CP103 = completedLine + Number(point_CP103);
  totalCompleted_CP103.push(tempComp_CP103);

  const totalCount_CP103 = totalUtilLine +  Number(point_CP103_a);
  totalUtil_CP103.push(totalCount_CP103);

} else if (cpPackage === 'CP104') {
  const tempComp_CP104 = completedLine + Number(point_CP104);
  totalCompleted_CP104.push(tempComp_CP104);

  const totalCount_CP104 = totalUtilLine +  Number(point_CP104_a);
  totalUtil_CP104.push(totalCount_CP104);

} else if (cpPackage === 'CP105') {
  const tempComp_CP105 = completedLine + Number(point_CP105);
  totalCompleted_CP105.push(tempComp_CP105);

  const totalCount_CP105 = totalUtilLine +  Number(point_CP105_a);
  totalUtil_CP105.push(totalCount_CP105);

} else if (cpPackage === 'CP108') {
  const tempComp_CP108 = completedLine + Number(point_CP108);
  totalCompleted_CP108.push(tempComp_CP108);

  const totalCount_CP108 = totalUtilLine +  Number(point_CP108_a);
  totalUtil_CP108.push(totalCount_CP108);

} else if (cpPackage === 'CP109') {
  const tempComp_CP109 = completedLine + Number(point_CP109);
  totalCompleted_CP109.push(tempComp_CP109);

  const totalCount_CP109 = totalUtilLine +  Number(point_CP109_a);
  totalUtil_CP109.push(totalCount_CP109);
  
}

});
const CP101 = (totalCompleted_CP101/gTotal)*100;
const CP102 = (totalCompleted_CP102/gTotal)*100;
const CP103 = (totalCompleted_CP103/gTotal)*100;
const CP104 = (totalCompleted_CP104/gTotal)*100;
const CP105 = (totalCompleted_CP105/gTotal)*100;
const CP108 = (totalCompleted_CP108/gTotal)*100;
const CP109 = (totalCompleted_CP109/gTotal)*100;

const CP101_a = (totalCompleted_CP101/totalUtil_CP101)*100;
const CP102_a = (totalCompleted_CP102/totalUtil_CP102)*100;
const CP103_a = (totalCompleted_CP103/totalUtil_CP103)*100;
const CP104_a = (totalCompleted_CP104/totalUtil_CP104)*100;
const CP105_a = (totalCompleted_CP105/totalUtil_CP105)*100;
const CP108_a = (totalCompleted_CP108/totalUtil_CP108)*100;
const CP109_a = (totalCompleted_CP109/totalUtil_CP109)*100;

return [CP101, CP102, CP103, CP104, CP105, CP108, CP109,
        CP101_a, CP102_a, CP103_a, CP104_a, CP105_a, CP108_a, CP109_a];
});
}

// Utility Progress Chart
function utilityChart([CP101, CP102, CP103, CP104, CP105, CP108, CP109, CP101_a, CP102_a, CP103_a, CP104_a, CP105_a, CP108_a, CP109_a]) {
    const totalScore = Number(CP101) + Number(CP102) + Number(CP103) + Number(CP104) + Number(CP105) + Number(CP108) + Number(CP109);

const CP_101 = Number(CP101);
const CP_102 = Number(CP101) + Number(CP102);
const CP_103 = Number(CP101) + Number(CP102) + Number(CP103);
const CP_104 = Number(CP101) + Number(CP102) + Number(CP103) + Number(CP104);
const CP_105 = Number(CP101) + Number(CP102) + Number(CP103) + Number(CP104) + Number(CP105);
const CP_108 = Number(CP101) + Number(CP102) + Number(CP103) + Number(CP104) + Number(CP105) + Number(CP108);
const CP_109 = Number(CP101) + Number(CP102) + Number(CP103) + Number(CP104) + Number(CP105) + Number(CP108) + Number(CP109);

var chartMin = 0;
var chartMax = 100;

// #ffea8c|#b3ab60|#4b595e|#6693c8|#aadbff
// const colors = ["#ffea8c", "#b3ab60", "#4b595e", "#6693c8", "#aadbff"];

var data = {
score: totalScore,
gradingData: [
{
  title: Number(CP101_a).toFixed(0),
  color: color_101,
  lowScore: 0,
  highScore: CP_101
},
{
  title: isNaN(CP109_a) ? "" : Number(CP102_a).toFixed(0),
  color: color_102,
  lowScore: CP_101,
  highScore: CP_102
},
{
  title: isNaN(CP109_a) ? "" : Number(CP103_a).toFixed(0),
  color: color_103,
  lowScore: CP_102,
  highScore: CP_103
},
{
  title: isNaN(CP109_a) ? "" : Number(CP104_a).toFixed(0),
  color: color_104,
  lowScore: CP_103,
  highScore: CP_104
},
{
  title: isNaN(CP109_a) ? "" : Number(CP105_a).toFixed(0),
  color: color_105,
  lowScore: CP_104,
  highScore: CP_105
},
{
  title: isNaN(CP109_a) ? "" : Number(CP108_a).toFixed(0),
  color: color_108,
  lowScore: CP_105,
  highScore: CP_108
},
{
  title: isNaN(CP109_a) ? "" : Number(CP109_a).toFixed(0),
  color: color_109,
  lowScore: CP_108,
  highScore: CP_109
},
{
  title: "",
  color: "#C5C5C5",
  lowScore: CP_109,
  highScore: 100
}
]
};

/**
Grading Lookup
*/
function lookUpGrade(lookupScore, grades) {
// Only change code below this line
for (var i = 0; i < grades.length; i++) {
if (
  grades[i].lowScore < lookupScore &&
  grades[i].highScore >= lookupScore
) {
  return grades[i];
}
}
return null;
}

// create chart
var chart = am4core.create("utilityPointChartDiv", am4charts.GaugeChart);
chart.hiddenState.properties.opacity = 0;
chart.fontSize = 11;
chart.innerRadius = am4core.percent(80);
chart.resizable = true;
chart.responsive.enabled = true;
/**
* Chart Title
*/
// Title Color

var title = chart.titles.create();
title.text = "UTILITY";
//title.html = '<a href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/civil/Operational/MMSP_Utility_Relocation/index.html" target="_blank">UTILITY</a>';
title.fontSize = titleFontSize;
title.align = "center";
title.marginBottom = -10;
title.marginTop = 0;
title.fill = TOP_TITLE_COL;

// Add bottom label
var label = chart.chartContainer.createChild(am4core.Label);
label.text = "[bold]COMPLETED";
label.fontSize = "1.4em";
label.align = "center";
label.marginTop = labelMarginTop;
label.fill = BOTTOM_LABEL_COL;

/**
* Normal axis
*/

var axis = chart.xAxes.push(new am4charts.ValueAxis());
axis.min = chartMin;
axis.max = chartMax;
axis.strictMinMax = true;
axis.renderer.radius = am4core.percent(80);
axis.renderer.inside = true;
axis.renderer.line.strokeOpacity = 0.5; // line opacity inside curve line
axis.renderer.ticks.template.disabled = false;
axis.renderer.ticks.template.strokeOpacity = 1;
//axis.renderer.ticks.template.strokeWidth = 1;
axis.renderer.ticks.template.length = 10;
axis.renderer.ticks.template.stroke = am4core.color(axis1TickColor);
//axis.renderer.grid.template.disabled = true;
axis.renderer.labels.template.radius = am4core.percent(40);
axis.renderer.labels.template.fontSize = "1.2em"; // default: 1.2em inner radius axis percent labels (0 to 100%)
axis.renderer.labels.template.fill = am4core.color(axis1TickColor);

/**
* Axis for ranges
*/

var axis2 = chart.xAxes.push(new am4charts.ValueAxis());
axis2.min = chartMin;
axis2.max = chartMax;
axis2.strictMinMax = true;
axis2.renderer.labels.template.disabled = true;
axis2.renderer.ticks.template.disabled = true;
axis2.renderer.grid.template.disabled = true; // when true inside tick marks will disappear
axis2.renderer.grid.template.opacity = 0.5;
axis2.renderer.labels.template.bent = true;
axis2.renderer.labels.template.fill = am4core.color("#000");
axis2.renderer.labels.template.fontWeight = "bold";
axis2.renderer.labels.template.fillOpacity = 0.7;



/**
Ranges
*/

for (let grading of data.gradingData) {
var range = axis2.axisRanges.create();
range.axisFill.fill = am4core.color(grading.color);
range.axisFill.fillOpacity = 1;
range.axisFill.zIndex = -1;
range.value = grading.lowScore > chartMin ? grading.lowScore : chartMin;
range.endValue = grading.highScore < chartMax ? grading.highScore : chartMax;
range.grid.strokeOpacity = 0; // changes opacity of inside tick mark
range.stroke = am4core.color(grading.color).lighten(-0.1);
range.label.inside = true;
range.label.text = grading.title.toUpperCase();
range.label.inside = true;
range.label.location = 0.5;
range.label.inside = true;
range.label.radius = am4core.percent(10);
range.label.paddingBottom = -5; // ~half font size
range.label.fontSize = "1.4em"; // category label (i.e., CP101, CP102, ....)
}

var matchingGrade = lookUpGrade(data.score, data.gradingData);

/**
* Label 1 (total Percent)
*/

var label = chart.radarContainer.createChild(am4core.Label);
label.isMeasured = false;
label.fontSize = "3.5em";
label.x = am4core.percent(50);
label.y = am4core.percent(100);
label.paddingBottom = -5;
label.horizontalCenter = "middle";
label.verticalCenter = "bottom";
//label.dataItem = data;
label.text = data.score.toFixed(0).toString() + "%";
//label.text = "{score}";
//label.fill = am4core.color(matchingGrade.color);
label.fill =  am4core.color(chartTitleLabelFillCol);

/**
* Label 2
*/

/*
var label2 = chart.radarContainer.createChild(am4core.Label);
label2.isMeasured = false;
label2.fontSize = titleFontSize;
label2.horizontalCenter = "middle";
label2.verticalCenter = "bottom";
label2.text = matchingGrade.title.toUpperCase();
//label2.fill = am4core.color(matchingGrade.color);
label2.fill =  am4core.color("#00C3FF");
*/
/**
* Hand
*/

var hand = chart.hands.push(new am4charts.ClockHand());
hand.axis = axis2;
hand.innerRadius = am4core.percent(55);
hand.startWidth = 8;
hand.pin.disabled = true;
hand.value = data.score;
hand.fill = am4core.color("#000000"); // inner color of needle
//hand.stroke = am4core.color("#000");
hand.fillOpacity = 0.5;

/*
hand.events.on("positionchanged", function(){
label.text = axis2.positionToValue(hand.currentPosition).toFixed(0).toString() + "%";
var value2 = axis.positionToValue(hand.currentPosition);
var matchingGrade = lookUpGrade(axis.positionToValue(hand.currentPosition), data.gradingData);
label2.text = matchingGrade.title.toUpperCase();
label2.fill = am4core.color(matchingGrade.color);
label2.stroke = am4core.color(matchingGrade.color);  
label.fill = am4core.color(matchingGrade.color);
})
*/
/*
setInterval(function() {
var value = chartMin + Math.random() * (chartMax - chartMin);
hand.showValue(value, 1000, am4core.ease.cubicOut);
}, 2000);
*/

}

function utilityAllChart() {
  utilityPointTotal()
  .then(utilityLineTotal)
  .then(utilityPointCompleted)
  .then(utilityLineCompleted)
  .then(utilityChart)
}

// Run all charts
lotChart();
lotChart2()
structureChart();
isfChart();
treeCuttingChart();
treeCompensationChart();
utilityAllChart();

/*
document.getElementById("thetabs").addEventListener("calciteTabsActivate", clickedTab);
function clickedTab(event) {
  const value = event.target.className;
  if (value === 'Subterranean') {
    utilityAllChart();
  }
}
*/
}); // end am4core.ready()


// Information widget
const itemDescription = document.getElementById("item-description");
itemDescription.innerHTML =  `
                              <div class="esri-widget" style='width:250px; padding:10px;'>
                              <li>This dashboard shows progress on key pre-construction works using gauges.</li><br>
                              <li>Total progress including all CPs is indicated in percent inside the gauge.</li><br>
                              <li>Progress of individual CPs is indicated in the sliced areas of each gauge with respective colors from Legend.</li>
                             </div>
                             `;


document.querySelector("calcite-button").addEventListener("click",function(response){
  itemDescription.hidden = !itemDescription.hidden;
});



});
  </script>
</html>