<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>General Progress (SC)</title>
    
    <link rel="stylesheet" href="https://js.arcgis.com/4.26/esri/themes/dark/main.css"/>
    <script type="module" src="https://js.arcgis.com/calcite-components/1.0.7/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.0.7/calcite.css" />

    <script src="https://js.arcgis.com/4.26/"></script>

  </head>
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }

    #overviewDiv {
      position: fixed;
      z-index: 1;
      top: 50px;
      width: 170px;
      height: 170px;
      border: 1px solid black;
      overflow: hidden;
    }

    #extentDiv {
        background-color: rgba(0, 0, 0, 0.5);
        position: absolute;
        z-index: 2;
      }

      #cardTitle {
        font-size: 15px;
      }

      calcite-button {
        padding: 3;
      }

    
    b {
        color: orange;
    }

    h2 {
      position: absolute;
      z-index: 99;
      top: 0;
      left: 0;
      margin: 1rem;
    }

    #dateDiv {
      position: absolute;
      z-index: 1;
      bottom: 0;
      right: 0;
      font-size: 0.7rem;
      text-align: right;
      display: flex;
      align-items: flex-end;
      font-weight: bold;
      margin: 1rem;

    }

    /* Project list*/
    #projectList {
      color: grey;
    }

    .active, .test:hover {
      background-color: rgba(77, 75, 75, 0);
        color: black;
        font-size: 1.2rem;
        /*text-decoration: underline;*/
        font-weight: bold;
    }

    ul {
      list-style-type: none; /* remove list bullets*/
    }

    .panel {
      box-sizing: border-box;
      width: 20%;
      position: absolute;
      text-align: left;
      top: 0;
      right: 0;
      font-size: 1rem;
      color: white;
      background-color: rgb(0, 0, 0, 0);
      overflow: auto;
      z-index: 99;
      /*transition: 3;*/
      line-height: 2rem;
      margin: 6;
      margin-right: 0;
      }

      h2 {
        font-size: 1.5rem;
      }

    /* Browser Setting */
    ::-webkit-scrollbar {
        display: none;
    }

    #logo-image {
      display: inline-block;
      position: fixed;
      z-index: 1;
      right: 0;
      bottom: 0;
      background-color: #d4d1ce;
      padding: 5;
    }

    #dotr-img,
    #mmsp-img,
    #gcr-img {
      width: 40;
      height: 40;
    }

    #legend-container-n1 {
      font-weight: bold;
      width: 100%;
    }

    #legend-container-mmsp {
      font-weight: bold;
      width: 100%;
    }

    #legend-container-n2 {
      font-weight: bold;
      width: 100%;
    }

    #legend-container-sc {
      font-weight: bold;
      width: 100%;
    }
    
    /*  */
    .sassy-theme .esri-legend__layer-caption {
      display: none;
    }
    
    .sassy-theme .esri-legend .esri-legend__layer-cell--info {
      /*background-color: black;*/
      color: "#f7f7f7";
      font-size: 0.8rem;
    }

    /*
    .sassy-theme .esri-widget--button {
      color: white;
    }
    */

    .sassy-theme .esri-compass .esri-compass__icon {
      font-size: 30px;
    }

    #train-Operation-schedule {
      width: 200px;
      height: 350px;
      position: fixed;
      z-index: 1;
      bottom: 0;
      left: 1%;
      margin: 15;
      /*opacity: 0%;*/
    }

    #compassDiv {
      height: 40px;
      width: 40px;
    }

    #stationContent1 {
        width: 10vw;
        height: auto;
        align-items: center;
        color: rgba(194, 194, 194, 0.884);
        font-size: 1.2em;
    }

    #stationContent2 {
        width: 10vw;
        height: auto;
        align-items: center;
        color: rgba(194, 194, 194, 0.884);
        font-size: 1.2em;
        padding-top: 2em;
    }

    #container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 5px;

    }

    h3 {
        font-size: 1.3vw;
        text-align: left;
        font-weight: bold;
        margin: 0%;
    }

  </style>
  <body class="sassy-theme">
    <calcite-loader></calcite-loader>
    <calcite-shell content-behind>
      <div id="overviewDiv"><div id="extentDiv"></div></div>
      <div id="viewDiv">
        <calcite-button
          href="https://eijigorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/others/General_Progress/index6.html"
          icon-end="launch"
          scale="s"
          label="Open Mariana Trench in map"
          target="_blank">
        </calcite-button>
        <!-- Title -->
        <!-- Check out this: https://developers.arcgis.com/calcite-design-system/components/button/ -->
        <h2 id="header-title"></h2>
        <div id="dateDiv"></div>
        <div id="legend-container-n1"></div>
        <div id="legend-container-mmsp"></div>
        <div id="legend-container-n2"></div>
        <div id="legend-container-sc"></div>
        <!-- Logo -->
        <!--
        <div id="logo-image">
          <img id="dotr-img" src="https://EijiGorilla.github.io/Symbols/Projec_Logo/DOTr_Logo_nobackground.png">
          <img id="mmsp-img" src="https://EijiGorilla.github.io/Symbols/Projec_Logo/MMSP_Logo_nobackground.png">
          <img id="gcr-img" src="https://EijiGorilla.github.io/Symbols/Projec_Logo/GCR_Logo_nobackground.png">  
        </div>
        -->
      <div id="compassDiv"></div>
      </div>
    </calcite-shell>
  </body>
  <script>
    require([
      "esri/Basemap",
      "esri/layers/VectorTileLayer",
      "esri/WebMap",
      "esri/views/MapView",
      "esri/Map",
      "esri/layers/FeatureLayer",
      "esri/widgets/Bookmarks",
      "esri/widgets/BasemapGallery",
      "esri/widgets/LayerList",
      "esri/widgets/Legend",
      "esri/rest/support/Query",
      "esri/widgets/Fullscreen",
      "esri/layers/support/FeatureFilter",
      "esri/widgets/TableList",
      "esri/portal/PortalItem",
      "esri/portal/Portal",
      "esri/rest/geometryService",
      "esri/rest/support/StatisticDefinition",
      "esri/symbols/WebStyleSymbol",
      "esri/widgets/Expand",
      "esri/renderers/UniqueValueRenderer",
      "esri/Ground",
      "esri/rest/support/RelationshipQuery",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/widgets/Search",
      "esri/widgets/Locate",
      "esri/widgets/BasemapToggle",
      "esri/PopupTemplate",
      "esri/layers/support/LabelClass",
      "esri/popup/content/CustomContent",
      "esri/layers/TileLayer",
      "esri/geometry/Extent",
      "esri/core/reactiveUtils",
      "esri/core/promiseUtils",
      "esri/layers/GroupLayer",
      "esri/widgets/Home",
      "esri/widgets/Print",
      "esri/geometry/Circle",
      "esri/widgets/Compass"
    ], function(Basemap, VectorTileLayer, WebMap, MapView, Map, FeatureLayer, Bookmarks, BasemapGallery, LayerList, Legend, 
                Query, Fullscreen, FeatureFilter, TableList, PortalItem, Portal, geometryService,
                StatisticDefinition, WebStyleSymbol, Expand, UniqueValueRenderer, Ground,
                RelationshipQuery, GraphicsLayer, Graphic, Search, Locate, BasemapToggle, PopupTemplate,
                LabelClass, CustomContent, TileLayer, Extent, reactiveUtils, promiseUtils, GroupLayer, Home, Print,
                Circle, Compass
                 ) {

    const basemap = new Basemap({
      baseLayers: [
          new VectorTileLayer({
          portalItem: {
              id: "824fe99ab989479f83b9a6d7f2da0bcb" // Light-gray:"75cf54bd051041c0a6244958cee3ab5c"
              // Dark-gray: "824fe99ab989479f83b9a6d7f2da0bcb"
          }
          })
      ]
    });
    
    var map = new Map({
        basemap: basemap,//basemap, // "streets-night-vector", basemap
        ground: "world-elevation"
    }); 
    //map.basemap.baseLayers.getItemAt(0).opacity = 1;
    //map.opacity = 0.1;
/*
      xmin: 13368016.94,
      xmax: 13552077.31,
      ymin: 1603544.28,
      ymax: 1712543.49,
*/

    const fixedExtent = new Extent({
      xmin: 13371235.35,
      xmax: 13545817.52,
      ymin: 1609731.16,
      ymax: 1718730.36,
      spatialReference: {
        wkid: 3857
      }
    });

    const home_rotation = 330;
    const home_center = [120.900000, 14.7832299];
    const home_scale = 292400;

    var view = new MapView({
        map: map,
        container: "viewDiv",
        //extent: fixedExtent,
        environment: {
          background: {
          type: "color", // autocasts as new ColorBackground()
          color: [0, 0, 0, 1]
          },
        },
        opacity: 0.5,
        rotation: home_rotation,
        center: home_center,
        scale: home_scale
    });


    // Inset maps (overview extent map)
    //https://www.esri.com/arcgis-blog/products/js-api-arcgis/mapping/inset-maps-for-the-web/
    //https://developers.arcgis.com/javascript/latest/sample-code/overview-map/
    //https://developers.arcgis.com/javascript/latest/sample-code/watch-for-changes/
    // sample smart map: https://ekenes.github.io/national-park-visits/?viewType=all&variable=bivariate&year=2021
    // Overview Extent
    var overViewMap = new Map({
        basemap: "streets-night-vector", // "streets-night-vector", basemap
    }); 

    const overViewCenter = [120.9411264, 14.7354620];
    const zoom = 5;

    var overView = new MapView({
        map: overViewMap,
        container: "overviewDiv",
        center: overViewCenter,
        zoom: zoom,
        //extent: fixedExtent,
        constraints: {
          rotationEnabled: false,
        },
        ui: {
          components: ["attribution"]
        }
    });

    view.ui.add("overviewDiv", "top-right");

    // Disable all the navigation
    overView.when(disableZooming);

function disableZooming(overView) {
  overView.popup.dockEnabled = true;

  // Removes the zoom action on the popup
  overView.popup.actions = [];

  // stops propagation of default behavior when an event fires
  function stopEvtPropagation(event) {
    event.stopPropagation();
  }

  // exlude the zoom widget from the default UI
  view.ui.components = [];
  overView.ui.components = [];

  // disable mouse wheel scroll zooming on the overView
  overView.on("mouse-wheel", stopEvtPropagation);

  // disable zooming via double-click on the overView
  overView.on("double-click", stopEvtPropagation);

  // disable zooming out via double-click + Control on the overView
  overView.on("double-click", ["Control"], stopEvtPropagation);

  // disables pinch-zoom and panning on the overView
  overView.on("drag", stopEvtPropagation);

  // disable the overView's zoom box to prevent the Shift + drag
  // and Shift + Control + drag zoom gestures.
  overView.on("drag", ["Shift"], stopEvtPropagation);
  overView.on("drag", ["Shift", "Control"], stopEvtPropagation);

  // prevents zooming with the + and - keys
  overView.on("key-down", (event) => {
    const prohibitedKeys = ["+", "-", "Shift", "_", "=", "ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft"];
    const keyPressed = event.key;
    if (prohibitedKeys.indexOf(keyPressed) !== -1) {
      event.stopPropagation();
    }
  });

  return overView;
}


        
///////////////////////////////////////////
    overView.when(() => {
      view.when(() => {
        setup();
      });
    });

    const extentDebouncer = promiseUtils.debounce(() => {
           overView.goTo({
              center: overViewCenter,
            });
        });


    function setup() {
      const extent3Dgraphic = new Graphic({
        geometry: null, // default: null
        symbol: {
          type: "simple-fill",
          color: [0, 0, 0, 0],
          outline: {
            width: 2,
            color: "#ff1947"//[178,34,34]
          }
        }
      });
      overView.graphics.add(extent3Dgraphic);

      reactiveUtils.watch(
        () => view.extent,
        (extent) => {
          // Sync the overview map location
          // whenever the 3d view is stationary
          extentDebouncer().then(() => {
            extent3Dgraphic.geometry = extent;
          });
        },
        {
          initial: true
        }
      );
    }
      
    //------------- Layer ----------------------------- /
    // Commercial Operatino Schdule image

    const labelStation_fontSize = 11;
    
    // Centerline
    // Color based on project
    const centerlineProjectColor = {
      nscr_hex: "#ff5f22",
      mmsp_hex: "#00b7ff", //"#0000ff"
      nscrex_hex: "#ff5f22",//"#00b3ff","#00B0F0", "#15C2FF"
    }

    const lineWidth = "5px";

    const lineSymbol_mmsp = {
      type: "simple",  // autocasts as new SimpleLineSymbol(),
      label: "MMSP",
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.mmsp_hex,
        width: lineWidth,
        style: "solid"
      }
    };

    const lineSymbol_nscr = {
      type: "simple",  // autocasts as new SimpleLineSymbol()
      label: "NSCR",
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.nscr_hex,
        width: lineWidth,
        style: "solid"
      }
    };

    const lineSymbol_nscrex = {
      type: "simple",  // autocasts as new SimpleLineSymbol(),
      label: "NSCR-Ex",
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.nscrex_hex,
        width: lineWidth,
        style: "solid"
      }
    };

    // Line symbol for overView
    const lineSymbolOverview_nscr = {
      type: "simple",  // autocasts as new SimpleLineSymbol()
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.nscr_hex,
        width: "2.5px",
        style: "solid"
      }
    };

    const lineSymbolOverview_mmsp = {
      type: "simple",  // autocasts as new SimpleLineSymbol()
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.mmsp_hex,
        width: "2.5px",
        style: "solid"
      }
    };

    const lineSymbolOverview_nscrex = {
      type: "simple",  // autocasts as new SimpleLineSymbol()
      symbol: {
        type: "simple-line",
        color: centerlineProjectColor.nscrex_hex,
        width: "2.5px",
        style: "solid"
      }
    };

    const pointSymbol = {
      type: "simple",  // autocasts as new SimpleLineSymbol()
      symbol: {
        type: "simple-marker",
        stlye: "circle",
        color: [0, 0, 0, 0.2],
        size: "3px",
        outline: {
          color: [0, 0, 0, 0],
          width: 0.5
        }
      } 
    }

    // Construction Progress symbol
    const tobeConstructed_color = "#b0c4d8"; //"#d9dc00";
    const underConstruction_color = "#ffff00"; //#3c6ccc
    const completedConstruction_color = "#dc4b00";

    const construction_lineWidth = "5px";

    const lineSymbol_construction = {
      type: "unique-value",  // autocasts as new SimpleLineSymbol(),
      field: "construcStat",
      legendOptions: {
        title: "Construction Status"
      },
      uniqueValueInfos: [
        {
          value: "To Be Constructed",
          label: "To be Constructed",
          symbol: {
            type: "simple-line",
            color: tobeConstructed_color,
            width: construction_lineWidth,
            style: "solid"
          }
        },
        {
          value: "On-going",
          label: "Under Construction",
          symbol: {
            type: "simple-line",
            color: underConstruction_color,
            width: construction_lineWidth,
            style: "solid"
          }
        },
        {
          value: "Completed",
          label: "Completed",
          symbol: {
            type: "simple-line",
            color: completedConstruction_color,
            width: construction_lineWidth,
            style: "solid"
          }
        },
      ]
    };


    var scCenterlineOverView = new FeatureLayer({
        portalItem: {
            id: "d3926383cf3548569372216edb808996",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
        renderer: lineSymbolOverview_nscrex,
        layerId: 7,
        popupEnabled: false,
    });
    overViewMap.add(scCenterlineOverView);


     // Station point feature
    const minScale = 577790;
    const minScale_stNumber = minScale + 1000;
    const maxScale = 0;
    const maxScale_stNumber = 288896;
    const opacity = 1;

    // Station point color
    // Alignment
    const pointSize = "10px";
    const pointColor = "white";
    const pointOutlineWidth = 1.5;

    const defaultStationPoint_nscr = {
      symbol: {
        type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
        style: "circle",
        color: pointColor,
        size: pointSize,  // pixels
        outline: {  // autocasts as new SimpleLineSymbol()
          color: centerlineProjectColor.nscr_hex,
          width: pointOutlineWidth  // points
        }
      }
    }

    const defaultStationPoint_mmsp = {
      symbol: {
        type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
        style: "circle",
        color: pointColor,
        size: pointSize,  // pixels
        outline: {  // autocasts as new SimpleLineSymbol()
          color: centerlineProjectColor.mmsp_hex,
          width: pointOutlineWidth  // points
        }
      }
    }

    const stationPointRenderer_construction_nscr = {
      type: "unique-value",
      field: "construcStatus",
      defaultSymbol: defaultStationPoint_nscr,
      uniqueValueInfos: [
        {
          value: "To Be Constructed",
          label: "To Be Constructed",
          symbol: {
            type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
            style: "circle",
            color: tobeConstructed_color,
            size: pointSize,  // pixels
            outline: {  // autocasts as new SimpleLineSymbol()
              color: centerlineProjectColor.nscr_hex,
              width: pointOutlineWidth  // points
            }
          }
        },
        {
          value: "On-going",
          label: "Under Construction",
          symbol: {
            type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
            style: "circle",
            color: underConstruction_color,
            size: pointSize,  // pixels
            outline: {  // autocasts as new SimpleLineSymbol()
              color: centerlineProjectColor.nscr_hex,
              width: pointOutlineWidth  // points
            }
          }
        },
        {
          value: "Completed",
          label: "Completed",
          symbol: {
            type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
            style: "circle",
            color: completedConstruction_color,
            size: pointSize,  // pixels
            outline: {  // autocasts as new SimpleLineSymbol()
              color: centerlineProjectColor.nscr_hex,
              width: pointOutlineWidth  // points
            }
          }
        },
      ]
    }

    const stationPointSymbol_nscr = {
      type: "simple",
      symbol: {
        type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
        style: "circle",
        color: pointColor,
        size: pointSize,  // pixels
        outline: {  // autocasts as new SimpleLineSymbol()
          color: centerlineProjectColor.nscr_hex,
          width: pointOutlineWidth  // points
        }
      }
    };

    const stationPointSymbol_mmsp = {
      type: "simple",
      symbol: {
        type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
        style: "circle",
        color: pointColor,
        size: pointSize,  // pixels
        outline: {  // autocasts as new SimpleLineSymbol()
          color: centerlineProjectColor.mmsp_hex,
          width: pointOutlineWidth  // points
        }
      }
    };

    // SC Station point layer
    var scLabelStation = new LabelClass({
        symbol: {
            type: "text",
            color: centerlineProjectColor.nscrex_hex,
            haloColor: "black",
            haloSize: 0.1,
            font: {
                size: labelStation_fontSize,
                //weight: "bold"
            }
        },
        deconflictionStrategy: "none", // show overlapping numbers
        labelPlacement: "center-right",
        labelExpressionInfo: {
            expression: "$feature.Station"
        },
        minScale: minScale,
        maxScale: maxScale,
    });

    var scStationLayer = new FeatureLayer({
        portalItem: {
            id: "d3926383cf3548569372216edb808996",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
        layerId: 2,
        title: "SC Station",
        outFields: ["*"],
        popupEnabled: false,
        labelingInfo: [scLabelStation], //[scLabelStation], 
        renderer: stationPointSymbol_nscr,
        opacity: opacity
    });
    scStationLayer.listMode = "hide";
    map.add(scStationLayer);

    var scBreakPointsCP = new FeatureLayer({
        portalItem: {
            id: "95bd8e4739af45189f2238faf626e5a0",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
        title: "SC Break Points",
        definitionExpression: "Extension = 'SC'" + " AND " + "Id >= 1",
        outFields: ["*"],
        popupEnabled: false,
        renderer: pointSymbol
    });
    scBreakPointsCP.listMode = "hide";
    map.add(scBreakPointsCP);

    // Construction Status using centerline
    // field name: 'Construction Status'
    // 'To Be Constructed', 'On-going', 'Completed'

    var scCenterlineConstruction = new FeatureLayer({
      portalItem: {
            id: "17eb4236364d482ca4c31f44b05f1d9a",
            portal: {
                url: "https://gis.railway-sector.com/portal"
            }
        },
        definitionExpression: "Extension = 'SC'",
        popupEnabled: false,
        renderer: lineSymbol_construction,
        outFields: ["*"]
    });
    map.add(scCenterlineConstruction, 0);


    var legend_construction_sc = new Legend({
      view,
      container: "construction-legend",
      layerInfos: [
        {
          layer: scCenterlineConstruction,
          title: "Construction Progress"
        }
      ]
    });
    view.ui.add(legend_construction_sc, "bottom-left");

    //----------------------------------------------------------------//
    const fontSizeAirport = 12;

    // Clark Internation Airport Pins
    var clarkAirport_pin = new FeatureLayer({
      portalItem: {
        id: "c4391b7c58ec4164922d9a223f3c0066",
      },
      layerId: 1,
      definitionExpression: "TITLE = 'Clark International Airport'",
      popupEnabled: false,
      opacity: 0
    });
    
    // Label 'Manila' on the map
    const clarkAirport_pin_pointGraphicLayer = new GraphicsLayer();
    clarkAirport_pin_pointGraphicLayer.listMode = 'hide';
    map.add(clarkAirport_pin_pointGraphicLayer);

    const clarkAirport_pin_lineGraphicsLayer = new GraphicsLayer({
      //maxScale: maxScale,
      //minScale: minScale
    });
    clarkAirport_pin_lineGraphicsLayer.listMode = 'hide';
    map.add(clarkAirport_pin_lineGraphicsLayer);
    
    var query = clarkAirport_pin.createQuery();
    clarkAirport_pin.queryFeatures(query).then(function(response) {
      var stats = response.features[0];

      // Create label point and label for 'Manila'
      const x0 = stats.geometry.longitude;
      const y0 = stats.geometry.latitude;
      const x1 = x0 - 0.10; // Offset
      const y1 = y0 - 0.15;

      const point = {
                    type: "point",
                    longitude: x1,
                    latitude: y0
                };

      let clarkAirport_textSymbol = {
        type: "text",  // autocasts as new TextSymbol()
        color: "white",
        //backgroundColor: projectBackgroundColor,
        text: "Clark Int. Airport",
        horizontalAlignment: "right",
        //yoffset: -5,
        font: {  // autocasts as new Font()
            size: fontSizeAirport,
            //family: "Merriweather",
            //style: "italic",
            //weight: "bold"
        }
        };

      const simpleMarkerSymbol = {
          type: "simple-marker",
          color: [226, 119, 40],
          size: 12,
          style: "circle",
          outline: {
              width: 1,
              color: [255, 255, 255, 1]
          }
      };

      const clarkAirport_PointGraphic = new Graphic({
          geometry: point,
          symbol: clarkAirport_textSymbol,
      });
      clarkAirport_pin_pointGraphicLayer.add(clarkAirport_PointGraphic);

      // Crate label line for 'Manila'
      // Create lin path and polyline
      const path = [
          [x0, y0],
          [x1, y0]
      ]

      const clarkAirport_pin_polyline = {
            type: "polyline",
            paths: path
        };

      // Set line properties
      const clarkAirport_pin_LineSymbol = {
          type: "simple-line",
          color: cpLineColor,
          width: cpLineWidth
      };

      // Add to Graphic
      const clarkAirport_pin_LineGraphic = new Graphic({
        geometry: clarkAirport_pin_polyline,
        symbol: clarkAirport_pin_LineSymbol
      });
      clarkAirport_pin_lineGraphicsLayer.add(clarkAirport_pin_LineGraphic);
    });


    //----------------------------------------------------------------//
    // Ninoy Internation Airport Pins
    var airport_pin = new FeatureLayer({
      portalItem: {
        id: "c4391b7c58ec4164922d9a223f3c0066",
      },
      layerId: 1,
      definitionExpression: "TITLE = 'Ninoy Aquino International Airport'",
      popupEnabled: false,
      opacity: 0
    });
    
    // Label 'Manila' on the map
    const airport_pin_pointGraphicLayer = new GraphicsLayer();
    airport_pin_pointGraphicLayer.listMode = 'hide';
    map.add(airport_pin_pointGraphicLayer);

    const airport_pin_lineGraphicsLayer = new GraphicsLayer({
      //maxScale: maxScale,
      //minScale: minScale
    });
    airport_pin_lineGraphicsLayer.listMode = 'hide';
    map.add(airport_pin_lineGraphicsLayer);
    
    var query = airport_pin.createQuery();
    airport_pin.queryFeatures(query).then(function(response) {
      var stats = response.features[0];

      // Create label point and label for 'Manila'
      const x0 = stats.geometry.longitude;
      const y0 = stats.geometry.latitude;
      const x1 = x0 - 0.10; // Offset

      const point = {
                    type: "point",
                    longitude: x1,
                    latitude: y0
                };

      let airport_textSymbol = {
        type: "text",  // autocasts as new TextSymbol()
        color: "white",
        //backgroundColor: projectBackgroundColor,
        text: "Ninoy Aquino Int. Airport",
        horizontalAlignment: "right",
        //yoffset: -5,
        font: {  // autocasts as new Font()
            size: fontSizeAirport,
            //family: "Merriweather",
            //style: "italic",
            //weight: "bold"
        }
        };

      const simpleMarkerSymbol = {
          type: "simple-marker",
          color: [226, 119, 40],
          size: 12,
          style: "circle",
          outline: {
              width: 1,
              color: [255, 255, 255, 1]
          }
      };

      const airport_PointGraphic = new Graphic({
          geometry: point,
          symbol: airport_textSymbol,
      });
      airport_pin_pointGraphicLayer.add(airport_PointGraphic);

      // Crate label line for 'Manila'
      // Create lin path and polyline
      const path = [
          [x0, y0],
          [x1, y0]
      ]

      const airport_pin_polyline = {
            type: "polyline",
            paths: path
        };

      // Set line properties
      const airport_pin_LineSymbol = {
          type: "simple-line",
          color: cpLineColor,
          width: cpLineWidth
      };

      // Add to Graphic
      const airport_pin_LineGraphic = new Graphic({
        geometry: airport_pin_polyline,
        symbol: airport_pin_LineSymbol
      });
      airport_pin_lineGraphicsLayer.add(airport_pin_LineGraphic);
    });

    //----------------------------------------------------------------//
    // Manila Pins
    var manila_pin = new FeatureLayer({
      portalItem: {
        id: "c4391b7c58ec4164922d9a223f3c0066",
      },
      layerId: 0,
      popupEnabled: false,
      opacity: 0
    });
    
    // Label 'Manila' on the map
    const manila_pin_pointGraphicLayer = new GraphicsLayer();
    manila_pin_pointGraphicLayer.listMode = 'hide';
    map.add(manila_pin_pointGraphicLayer);

    const manila_pin_lineGraphicsLayer = new GraphicsLayer({
      //maxScale: maxScale,
      //minScale: minScale
    });
    manila_pin_lineGraphicsLayer.listMode = 'hide';
    map.add(manila_pin_lineGraphicsLayer);
    
    var query = manila_pin.createQuery();
    manila_pin.queryFeatures(query).then(function(response) {
      var stats = response.features[0];

      // Create label point and label for 'Manila'
      const x0 = stats.geometry.longitude;
      const y0 = stats.geometry.latitude;
      const x1 = x0 - 0.15; // Offset

      const point = {
                    type: "point",
                    longitude: x1,
                    latitude: y0
                };

      let manila_textSymbol = {
        type: "text",  // autocasts as new TextSymbol()
        color: "white",
        //backgroundColor: projectBackgroundColor,
        text: "Manila",
        horizontalAlignment: "right",
        //yoffset: -5,
        font: {  // autocasts as new Font()
            size: 15,
            //family: "Merriweather",
            //style: "italic",
            weight: "bold"
        }
        };

      const simpleMarkerSymbol = {
          type: "simple-marker",
          color: [226, 119, 40],
          size: 12,
          style: "circle",
          outline: {
              width: 1,
              color: [255, 255, 255, 1]
          }
      };

      const manila_PointGraphic = new Graphic({
          geometry: point,
          symbol: manila_textSymbol,
      });
      manila_pin_pointGraphicLayer.add(manila_PointGraphic);

      // Crate label line for 'Manila'
      // Create lin path and polyline
      const path = [
          [x0, y0],
          [x1, y0]
      ]

      const manila_pin_polyline = {
            type: "polyline",
            paths: path
        };

      // Set line properties
      const manila_pin_LineSymbol = {
          type: "simple-line",
          color: cpLineColor,
          width: cpLineWidth
      };

      // Add to Graphic
      const manila_pin_LineGraphic = new Graphic({
        geometry: manila_pin_polyline,
        symbol: manila_pin_LineSymbol
      });
      manila_pin_lineGraphicsLayer.add(manila_pin_LineGraphic);
    });
    //----------------------------------------------------------------//

    /////////////////// END Of LAYER IMPORT ////////////////////////////
  // Zoom
  function zoomToLayer(layer) {
    return layer.queryExtent().then(function(response) {
      view.goTo(response.extent, { //response.extent
        speedFactor: 2
      }).catch(function(error) {
        if (error.name != "AbortError") {
          console.error(error);
        }
      });
    });
  }

    // Draw CP break line on the map
    // Project Label properties
    const projectLabelColor = "#000000"
    const projectBackgroundColor = "#0062a8" //"#007fd9"
    const projectLabelFontSize = 13;


    // Point and Line feature
    const cpLineColor = "#f0f4f7";
    const cpLabelColor = "#f0f4f7";

    const cpLineWidth = 0.3;
    const cpFontSize = 10;

    // SC
    const scGraphicsLayer = new GraphicsLayer();
      scGraphicsLayer.listMode = "hide";
      map.add(scGraphicsLayer);

      const scGraphicsLayer_cpLabel = new GraphicsLayer({
        maxScale: maxScale,
        minScale: minScale
      });
      scGraphicsLayer_cpLabel.listMode = "hide";
      map.add(scGraphicsLayer_cpLabel);

    function scGraphics(xoffset, yoffset){
      var query = scBreakPointsCP.createQuery();
      query.orderByFields = ["Id"];

        scBreakPointsCP.queryFeatures(query).then(function(response) {
          var stats = response.features;
          const paths = [];
          const points = [];
          const CPs = [];

          stats.forEach((result, index) => {
              // Collect geometry of each break point
              const attributes = result.attributes;
              const cp = attributes.CP;
              CPs.push(cp);
              const pointX0 = result.geometry.longitude;
              const pointY0 = result.geometry.latitude;

              // Calculate end poins and store it in a path for line generation
              const pointX1 = pointX0 - 0.05;
              const path = [
                  [pointX0, pointY0],
                  [pointX1, pointY0]
              ]

              // Append each path to paths
              paths.push(path);

              // Calculate a point for text symbol
              const point = [pointX1, pointY0];
              points.push(point);
          });

          // 1. Draw a horizontal line at break points of individual CPs
          // Define polyline paths and type
          const polyline = {
              type: "polyline",
              paths: paths
          };

          // Set line properties
          const simpleLineSymbol = {
              type: "simple-line",
              color: cpLineColor,
              width: cpLineWidth
          };

          // Add to Graphic
          const scPolylineGraphic = new Graphic({
              geometry: polyline,
              symbol: simpleLineSymbol
          });
          scGraphicsLayer_cpLabel.add(scPolylineGraphic);
          // Dispaly grapchicsLayer


          // 2. Add text symbol
          for(var i=0; i < points.length; i++){
              //console.log(i);
              if(i <= points.length-2 && i !== 8){
                  const pointTextX = points[i][0] - 0.01;
                  const pointTextY0 = points[i][1] - 0.05;
                  const pointTextY1 = points[i+1][1];
                  const pointTextY = (pointTextY0 + pointTextY1) / 2;

                  const point = {
                      type: "point",
                      longitude: pointTextX,
                      latitude: pointTextY
                  };

                  let textSymbol = {
                      type: "text",  // autocasts as new TextSymbol()
                      color: cpLabelColor,
                      //haloColor: "black",
                      //haloSize: "1px",
                      text: CPs[i],
                      //xoffset: 3,
                      //yoffset: -5,
                      font: {  // autocasts as new Font()
                          size: cpFontSize,
                          //family: "Josefin Slab",
                          weight: "bold"
                      }
                  };

                  const simpleMarkerSymbol = {
                      type: "simple-marker",
                      color: [226, 119, 40],
                      size: 12,
                      style: "circle",
                      outline: {
                          width: 1,
                          color: [255, 255, 255, 1]
                      }
                  };

                  const scPointGraphic = new Graphic({
                      geometry: point,
                      symbol: textSymbol
                  });
                  scGraphicsLayer_cpLabel.add(scPointGraphic);
              }
          }

          // Add Project label (SC)
          let scProjectLableSymbol = {
            type: "text",  // autocasts as new TextSymbol()
            color: centerlineProjectColor.nscrex_hex,
            //backgroundColor: projectBackgroundColor,
            //haloColor: "black",
            //haloSize: "1px",
            text: "North-South Commuter Railway Ext.\n(Solis-Calamba)\n55km",
            horizontalAlignment: "right",
            //xoffset: 3,
            //yoffset: -5,
            font: {  // autocasts as new Font()
              size: projectLabelFontSize,
              //family: "Merriweather",
              //style: "italic",
              weight: "bold"
            }
          };
          const j = 5;
          //console.log("SC label: " + points);
          const pointTextX_pLabel = points[j][0] + 0.50 + xoffset;
          const pointTextY0_pLabel = points[j][1] - 0.55 + yoffset;
          const pointTextY1_pLabel = points[j+1][1];
          const pointTextY_pLabel = (pointTextY0_pLabel + pointTextY1_pLabel) / 2;

          const projectPoint = {
              type: "point",
              longitude: pointTextX_pLabel,
              latitude: pointTextY_pLabel
          };

            const scProjectLabelGraphic = new Graphic({
              geometry: projectPoint,
              symbol: scProjectLableSymbol
            });

            scGraphicsLayer.add(scProjectLabelGraphic); // Do not use graphicslayer.addMany. 
      }); // end of queryFeatures
  }
  // Initial
  scGraphics(-0.15,0.9);
  

   function homeExtentRenderer() {
      view.rotation = home_rotation;
      view.scale = 577790.5542885;
      view.center = home_center;
    }




        ///////////////////////////////

    view.ui.add(document.querySelector("calcite-button"), "top-left");
    
    const segmentedItemsExpand = new Expand({
      view: view,
      expanded: true,
      content: document.getElementById("information")
    });


    //segmentedDateDiv.style.display = 'none';
    const overviewDiv = document.getElementById("overviewDiv");
    view.ui.add("overviewDiv", "top-right");

    // Legend

    // Compass
    let compass = new Compass({
      view: view,
      container: document.getElementById("compassDiv")
    });

    view.ui.add(document.getElementById("alingment-progress-switch"), "bottom-right");

    // adds the compass to the top left corner of the MapView
    view.ui.add(compass, "top-left");

    ///////////////////////////////////////////////////////
       //*******************************************************************
        // Watching properties for changes
        // 1. Watch view.stationary property
        // 2. Watch visible property of popup
        //*******************************************************************
        // Watch view's stationary property for becoming true.
        reactiveUtils.when(
          () => view.stationary === true,
          () => {
            zoomToLayer(scStationLayer);
            view.rotation = 360;

            // Get the new center of the view only when view is stationary.
            if (view.center) {
              const info = `
              x: ${view.center.x.toFixed(2)}
              y: ${view.center.y.toFixed(2)}`;
              
        
            }
            // Get the new extent of the view only when view is stationary.
            if (view.extent) {
              const info = `
              xmin: ${view.extent.xmin.toFixed(2)},
              xmax: ${view.extent.xmax.toFixed(2)},
              ymin: ${view.extent.ymin.toFixed(2)},
              ymax: ${view.extent.ymax.toFixed(2)},`;
              console.log(info);
            }

            if (view.scale) {
              const info = `scale: ${view.scale}`
              console.log(info);
            }

            /*
            if (view.scale > maxScale_stNumber || view.scale < minScale_stNumber) {
              stationExpand.expanded = !stationExpand.expanded;
            }
            */
          }
        );

    });
  </script>
</html>