<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Use three.js from an external renderer - 4.1</title>

    <link rel="stylesheet" href="https://js.arcgis.com/4.24/esri/css/main.css">

    <script src="https://unpkg.com/three@0.144.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.144.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/7/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script src="https://js.arcgis.com/4.24/"></script>

    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        #paneDiv {
            position: absolute;
            top: 18px;
            right: 18px;
            padding: 12px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
        }
    </style>

    <!-- Our application -->
    <script>
        require([
          "esri/core/Accessor",
          "esri/Map",
          "esri/views/SceneView",
          "esri/geometry/Point",
          "esri/geometry/Polyline",
          "esri/views/3d/externalRenderers",
          "esri/geometry/SpatialReference",
          "esri/rest/route",
          "esri/rest/support/RouteParameters",
          "esri/rest/support/FeatureSet",
          "esri/layers/GraphicsLayer",
          "esri/Graphic",
          "esri/symbols/SimpleMarkerSymbol",
          "esri/symbols/SimpleLineSymbol",
          "esri/Color",
          "esri/geometry/geometryEngine",
          "esri/core/urlUtils",
          "dojo/on",
          "dojo/query",
          "dojo/domReady!"
        ],
        function (
        Accessor,
          Map,
          SceneView,
          Point,
          Polyline,
          externalRenderers,
          SpatialReference,
          route,
          RouteParameters,
          FeatureSet,
          GraphicsLayer,
          Graphic,
          SimpleMarkerSymbol,
          SimpleLineSymbol,
          Color,
          geometryEngine,
          urlUtils,
          on,
          query
        ) {
            // The stops and route result will be stored in this layer
            var routeLyr = new GraphicsLayer();

            // Setup the route parameters
            var routeParams = new RouteParameters({
                stops: new FeatureSet(),
                outSpatialReference: { // autocasts as new SpatialReference()
                    wkid: 3857
                }
            });

            // Define the symbology used to display the stops
            var stopSymbol = new SimpleMarkerSymbol({
                style: "cross",
                size: 15,
                outline: { // autocasts as new SimpleLineSymbol()
                    width: 4
                }
            });

            // Define the symbology used to display the route
            var routeSymbol = new SimpleLineSymbol({
                color: [0, 0, 255, 0.5],
                width: 5
            });
            // Create a map
            //////////////////////////////////////////////////////////////////////////////////////
            var map = new Map({
                basemap: "dark-gray-vector",
                ground: "world-elevation",
              layers: [routeLyr]
            });

            // Create a SceneView
            //////////////////////////////////////////////////////////////////////////////////////
            var view = new SceneView({
                container: "viewDiv",
                map: map,
                viewingMode: "global",
                camera: {
                    position: {
                        x: 9,
                        y: 45,
                        z: 10000,
                        spatialReference: SpatialReference.WGS84
                    },
                    heading: 0,
                    tilt: 35
                },
                environment: {
                    background: {
                        type: "color", // autocasts as new ColorBackground()
                        color: [0, 0, 0, 1]
                    }
                }
            });

            // Adds a graphic when the user clicks the map. If 2 or more points exist, route is solved.
            //on(view, "click", addStop);
            view.on("click", function() {
                addStop();

            });

            function addStop(event) {

                // Add a point at the location of the map click
                //var stop = new Graphic({
                //    geometry: event.mapPoint,
                //    symbol: stopSymbol
                //});

                var stop1 = new Graphic({
                    geometry: new Point({x: 998349.73209999874, y: 5631130.5138999969, spatialReference: SpatialReference.WebMercator}),
                    symbol: stopSymbol
                });
                

                routeLyr.add(stop1);

                var stop2 = new Graphic({
                    geometry: new Point({x: 1003417.1920999996, y: 5631433.9733999968, spatialReference: SpatialReference.WebMercator }),
                    symbol: stopSymbol
                });

                routeLyr.add(stop2);

                
                routeParams.stops.features.push(stop1);
                routeParams.stops.features.push(stop2);

                // Execute the route task if 2 or more stops are input
                //routeParams.stops.features.push(stop);
                if (routeParams.stops.features.length >= 2) {
                    //routeTask.solve(routeParams).then(showRoute);
                    showRoute();
                }
            }


            // Adds the solved route to the map as a graphic
            function showRoute(data) {
                
                //var routeResult = data.routeResults[0].route;


                var polyline = new Polyline([[998349.73209999874, 5631130.5138999969], [998362.17399999872, 5631126.6533000022], [998457.90879999846, 5631229.0921000019], [998552.53029999882, 5631323.6520999968],
                    [998610.41649999842, 5631386.6926999986], [998636.01999999955, 5631418.2131000012], [998650.4915000014, 5631435.5494000018], [998676.09499999881, 5631467.0700000003],
                    [998682.77409999818, 5631474.9501999989], [998732.86789999902, 5631533.2635999992], [998839.73460000008, 5631646.7396000028], [998952.16730000079, 5631719.2387999967],
                    [998988.90269999951, 5631733.4235000014], [999191.50420000032, 5631790.1626000032], [999306.16330000013, 5631821.6843999997], [999581.12240000069, 5631898.9134000018],
                    [999795.96909999847, 5631954.0773999989], [999954.04270000011, 5631939.8923000023], [1000178.9081000015, 5631820.1083000004], [1000821.2215999998, 5631456.0377999991],
                    [1000953.6917999983, 5631415.060999997], [1001226.4244999997, 5631377.2365000024], [1001712.8907000013, 5631311.0441000015], [1001873.1906999983, 5631304.7400000021],
                    [1002203.8095999993, 5631322.0760999992], [1002398.6187000014, 5631340.9882000014], [1002457.6180999987, 5631377.2365000024], [1002649.0876000002, 5631605.762000002],
                    [1002683.5965999998, 5631619.9465000033], [1002892.8773000017, 5631509.6230000034], [1002995.2912000008, 5631454.4616999999], [1003084.3467999995, 5631422.941200003],
                    [1003281.3823000006, 5631456.0377999991], [1003348.1739999987, 5631448.1576000005], [1003413.5742000006, 5631433.9733999968], [1003417.1920999996, 5631433.9733999968]]);
                polyline.spatialReference = SpatialReference.WebMercator;

                var routeResult = new Graphic({
                    geometry: polyline,
                    symbol: routeSymbol
                });

                routeResult.symbol = routeSymbol;

                routeLyr.add(routeResult);

                var pl = geometryEngine.densify(routeResult.geometry, 10, "meters");
      
                // register the external renderer
                const myExternalRenderer = new skeletonRenderer(view, pl);
                externalRenderers.add(view, myExternalRenderer);

            }
            // Disable lighting based on the current camera position.
            // We want to display the lighting according to the current time of day.
            view.environment.lighting.cameraTrackingEnabled = false;

            // Create our custom external renderer
            //////////////////////////////////////////////////////////////////////////////////////
            //https://github.nicogis.it/externalRendererSkeleton/
            var skeletonRenderer = Accessor.createSubclass({ // if '|| {}' is not added beside null,
            // you will receive the following error 'Cannot destructure property of xx of 'null' as it is null'
                view: null,
                //pl: null,
                renderer: null,     // three.js renderer
                camera: null,       // three.js camera
                scene: null,        // three.js scene
                vertexIdx: 0,
                ambient: null,      // three.js ambient light source
                sun: null,          // three.js sun light source
                mixer: null,
                clock: null,
                clips: null,
                animate: null,
                light: null,
                iss: null,                                                    // ISS model
                issScale: 100,                                     // scale for the iss model
                path: null,
              count: null,
              up: null,
              timeDelta: null,

                cameraPositionInitialized: false, // we focus the view on the ISS once we receive our first data point
                positionHistory: [],
              
                constructor: function (view, pl) {
                  this.view = view;
                    this.path = pl.paths[0]; //pl.paths[0];
                },
                /**
                 * Setup function, called once by the ArcGIS JS API.
                 */
                setup: function (context) {

                    // initialize the three.js renderer
                    //////////////////////////////////////////////////////////////////////////////////////
                    this.renderer = new THREE.WebGLRenderer({
                        context: context.gl,
                        premultipliedAlpha: false
                    });
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.renderer.setSize(context.camera.fullWidth, context.camera.fullHeight);
                    this.renderer.setViewport(0, 0, view.width, view.height);

                    // prevent three.js from clearing the buffers provided by the ArcGIS JS API.
                    this.renderer.autoClearDepth = false;
                    this.renderer.autoClearStencil = false;
                    this.renderer.autoClearColor = false;

                    // The ArcGIS JS API renders to custom offscreen buffers, and not to the default framebuffers.
                    // We have to inject this bit of code into the three.js runtime in order for it to bind those
                    // buffers instead of the default ones.
                    var originalSetRenderTarget = this.renderer.setRenderTarget.bind(this.renderer);
                    this.renderer.setRenderTarget = function (target) {
                        originalSetRenderTarget(target);
                        if (target == null) {
                            context.bindRenderTarget();
                        }
                    }

                    // setup the three.js scene
                    //////////////////////////////////////////////////////////////////////////////////////         
                    this.scene = new THREE.Scene();

                    // setup the camera
                    this.camera = new THREE.PerspectiveCamera();

                    // setup scene lighting
                    this.ambient = new THREE.AmbientLight(0xffffff, 0.5);
                    this.scene.add(this.ambient);
                    this.sun = new THREE.DirectionalLight(0xffffff, 0.5);
                    this.scene.add(this.sun);

                    this.clock = new THREE.Clock();

                    var issMeshUrl = "https://EijiGorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/Sample/Three_js/3d-model-gltf/assets/Truck.gltf";
                    //"https://EijiGorilla.github.io/WebApp/ArcGIS_API_for_JavaScript/Sample/Three_js/3d-model-gltf/assets/Wraith_Animated.glb";
                    // "https://EijiGorilla.github.io/glTF/canoe.glb"

                    var loaderGLTF = new THREE.GLTFLoader(); // check this: https://qgenhate.hatenablog.com/ [object not an instance of THREE.Object3D]
                    let example = new THREE.Object3D();
      
                    loaderGLTF.load(issMeshUrl,
                    function(gltf) {
                        console.log("ISS mesh loaded.");
                       
                        example = gltf.scene;
                        this.iss = example;
                        
                        // apply ISS material to all nodes in the geometry
                        //this.iss.traverse( function ( child ) {
                        //  if ( child instanceof THREE.Mesh ) {
                        //    child.material = this.issMaterial;
                        //  }
                        //}.bind(this));
                        
                        // set the specified scale for the model
                        this.iss.scale.set(this.issScale, this.issScale, this.issScale);
                        
                        // add the model
                        this.scene.add(this.iss); // original: this.iss
                        console.log("ISS mesh added.");

                        // Mixer for animation
                        this.mixer = new THREE.AnimationMixer(this.iss);
                        this.mixer.clipAction(gltf.animations[0]).play();


                       //this.iss.update(stepSize);
                        //this.clips = this.iss.animations;
                        // update animated object
                        // requestAnimationFrame();
                    
                    }.bind(this), undefined, function(error) {
                        console.error("Error loading ISS mesh. ", error);
                    });

                    this.light = new THREE.DirectionalLight(0xffffff, 1);
                    this.light.position.set(2,2,5);
                    this.scene.add(this.light);
                  
                  // rotation 
                      this.up = new THREE.Vector3(1, 0, 1); // used with lookAt: look at the next point at x-axis
                      this.axis = new THREE.Vector3();
                      this.n  = new THREE.Vector3( ); // normal,
                      this.b  = new THREE.Vector3( ); // binormal
                      this.M3 = new THREE.Matrix3( );
                      this.M4 = new THREE.Matrix4( );
                      this.pp = new THREE.Vector3( );
                      this.quaternion = new THREE.Quaternion();

                    // cleanup after ourselfs
                    context.resetWebGLState();
                },
                render: function (context) {

                    // update camera parameters
                    ///////////////////////////////////////////////////////////////////////////////////
                    var cam = context.camera;

                    this.camera.position.set(cam.eye[0], cam.eye[1], cam.eye[2]);
                    this.camera.up.set(cam.up[0], cam.up[1], cam.up[2]);
                    this.camera.lookAt(new THREE.Vector3(cam.center[0], cam.center[1], cam.center[2]));

                    // Projection matrix can be copied directly
                    this.camera.projectionMatrix.fromArray(cam.projectionMatrix);
                  

                    if (this.iss) {
                             
                        // Add this.mixer.update first; otherwise, the object will not be animated.s
                        if (this.mixer) {
                            var scale = 0.0001; //this.gui.getTimeScale();
                            var delta = this.clock.getDelta();

                          this.mixer.update(delta);         
                        }
   
                            if (this.path.length == (this.vertexIdx + 1))
                        {
                            this.vertexIdx = 0;
                        }
                      
                        var p = this.path[this.vertexIdx]; // vertexIdx = 0
                      var p1 = this.path[this.vertexIdx + 1];
                    
                      // Define Z:
                      // It is important that the same Z values are set for both current (pt) and next points (pt1)
                      // Otherwise, the object will be tilted.
                      const changeZ = 0;
                      const offsetZ = 140;

                        var pt = new Point({
                            x: p[0], // longitude
                            y: p[1], // latitude
                            z: 0
                        });

                        pt.spatialReference = SpatialReference.WebMercator;

                        z = offsetZ; // view.basemapTerrain.getElevation(p);

                        pos = [pt.x, pt.y, z];

                        this.vertexIdx++;

                        if (this.path.length == (this.vertexIdx)) {
                            this.vertexIdx--;
                        }
                      
                      // we need transformation matrix
                      //This allows a Vector3 representing a point in 3D space to undergo
                      //transformations such as translation, rotation, shear, scale, 
                      //reflection,orthogonal or perspective projection and so on, 
                      //by being multiplied by the matrix.
                      //This is known as applying the matrix to the vector.

                      // We must transform location of 3D Object from existing local Cartesian (geodesic) to world coordinate sytem. externalRenderers.renderCoordinateTranformAt does this.
                        var transform = new THREE.Matrix4();
                        transform.fromArray(externalRenderers.renderCoordinateTransformAt(view, pos, SpatialReference.WebMercator, new Array(16)));
                      
                      //console.log(transform.elements[12], transform.elements[13], transform.elements[11]);

                       this.iss.position.set(transform.elements[12], transform.elements[13], transform.elements[14]);
                      
                      this.count ++;
                        if (this.count === 1) {
                          console.log(transform.elements[12], transform.elements[13], transform.elements[14]);
                        }
                           
                     
                    
                        var p0;
                        var p1;

                        if ((this.path.length - 1) == (this.vertexIdx))
                        {
                            p0 = this.path[--this.vertexIdx];
                            p1 = this.path[this.vertexIdx];
                        }
                        else
                        {
                            p0 = this.path[this.vertexIdx];
                            p1 = this.path[++this.vertexIdx];
                        }
                      
                     // Option 1: use lookAt 
                      
                      var rotation = new THREE.Matrix4();
                      
                        var pt1 = new Point({
                            x: p1[0], // longitude
                            y: p1[1], // latitude
                            z: offsetZ
                        });
                      posR = [pt1.x, pt1.y, pt1.z];
                      rotation.fromArray(externalRenderers.renderCoordinateTransformAt(view, posR, SpatialReference.WebMercator, new Array(16)));
                      // https://answers.unity.com/questions/36255/lookat-to-only-rotate-on-y-axis-how.html
                      // how to use '.up' with lookAt?
                      //geometry.applyMatrix4( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
                      this.iss.up = this.up;
                      
                      this.iss.lookAt(rotation.elements[12], rotation.elements[13], rotation.elements[14]);
              
                      // transformation matrix for rotation
                      /*
                        var rotation = new THREE.Matrix4();
                        var m1 = new THREE.Matrix4(); // transformation matrix for x axis
                        var m2 = new THREE.Matrix4(); // transformation matrix for y axis
                        var m3 = new THREE.Matrix4(); // transformation matrix for z axis
                     
                      // 
                      // https://stackoverflow.com/questions/11179327/orient-objects-rotation-to-a-spline-point-tangent-in-three-js
                      // tangent = spline.getTangent(t).normalize();
                      // axis.crossVectors(up, tangent).normalize();
                      // radians = Math.acos(up.dot(tangent));
                      // marker.quaternion.setFromAxisAngle(axis, radians);
                      // keyword: motion along curve (https://hofk.de/main/discourse.threejs/2021/MotionAlongCurve/MotionAlongCurve.html)
                      // https://hofk.de/main/discourse.threejs/2021/MovementOnCurve/MovementOnCurve.html
                   //https://observablehq.com/@rveciana/three-js-object-moving-object-along-path
                  // https://stackoverflow.com/questions/13757483/three-js-lookat-seems-to-be-flipped
                  
                      //console.log(newHeading);                     
                        m1.makeRotationX(THREE.MathUtils.degToRad(90)); // 90
                        m2.makeRotationY(THREE.MathUtils.degToRad(10)); // 10
                        m3.makeRotationZ(THREE.MathUtils.degToRad(315)); // 315

                        rotation.multiplyMatrices(m1, m2);
                        rotation.multiply(m3);

                       this.iss.setRotationFromMatrix(rotation);
                    */

                        var scale = 0.1; //this.gui.getTimeScale();
                        var delta = this.clock.getDelta();
                        var stepSize = delta * scale;
                       //this.iss.update(stepSize);
                        
                    }

                    // update lighting
                    /////////////////////////////////////////////////////////////////////////////////////////////////////
                    //view.environment.lighting.date = Date.now();

                    var l = context.sunLight;
                    this.sun.position.set(
                      l.direction[0],
                      l.direction[1],
                      l.direction[2]
                    );
                    this.sun.intensity = l.diffuse.intensity;
                    this.sun.color = new THREE.Color(l.diffuse.color[0], l.diffuse.color[1], l.diffuse.color[2]);

                    this.ambient.intensity = l.ambient.intensity;
                    this.ambient.color = new THREE.Color(l.ambient.color[0], l.ambient.color[1], l.ambient.color[2]);

                    // draw the scene
                    /////////////////////////////////////////////////////////////////////////////////////////////////////
                    this.renderer.resetState();
                    context.bindRenderTarget();
                    this.renderer.render(this.scene, this.camera);
                    externalRenderers.requestRender(view);

                    // cleanup
                    context.resetWebGLState();
                },
            })
            externalRenderers.add(view, skeletonRenderer);

            view.when(function() {
                // allow navigation above and below the ground
                map.ground.navigationConstraint = {
                    type: "none"
                };
                // the webscene has no basemap, so set a surfaceColor on the ground
                map.ground.surfaceColor = "#fff";
        
                // to see through the ground, set the ground opacity to 0.4
                map.ground.opacity = 0.9;
            });
        });
    </script>
</head>
<body>
    <div id="viewDiv"></div>
</body>
</html>